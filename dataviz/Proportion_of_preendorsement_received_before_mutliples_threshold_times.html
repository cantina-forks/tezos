<!doctype html>

<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Proportion of preendorsement received before mutliples threshold times</title>
    <script src=https://cdnjs.cloudflare.com/ajax/libs/mathjs/3.3.0/math.min.js></script>
    <script src="https://cdn.jsdelivr.net/npm/d3@7.4.4/dist/d3.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-legend/2.13.0/d3-legend.js"></script>
</head>

<body>
    <h1> Proportion of preendorsement received before mutliples threshold times </h1>
    <form>
        <div>
            <label for="selectedLevel_begin">First bloc:</label>
            <input name="level_" id="selectedLevel_begin" type="number" value="2412550" />
            <span id='tick_begin'></span>
            <br>
            <label for="selectedLevel_end">Last bloc:</label>
            <input name="level_" id="selectedLevel_end" type="number" value="2412700" />
            <span id='tick_end'></span>
            <br>
            <label for="selectedThreshold_begin">lower threshold time(second):</label>
            <input name="threshold" id="selectedThreshold_beg" type="number" value="1" />
            <br>
            <label for="selectedThreshold_end">higher threshold time(second):</label>
            <input name="threshold" id="selectedThreshold_end" type="number" value="30" />
            <br>
            <input type="button" id="submit_" value="Rechercher ">

        </div>
    </form>
    <div id="gamma"></div>

    <script>
        const server_adress = "http://78.193.200.52";
        var directories = {};
        var dict_data = {};
        var directories = {};
        var t_op_retard = {}; // contient plusieurs dict, chacun associé à un round/type(preendo ou endo)
        var t_op_valide = {}; // t_op_erreur[k]= t_op_erreur_i
        var t_op_pre_retard = {}; // contient plusieurs dict, chacun associé à un round/type(preendo ou endo)
        var t_op_pre_valide = {}; // contient plusieurs dict, chacun associé à un round. Ces dict contiennent 2 listes, qui sont les délais de réception pour les Préendorsement et les endorsmenet invalides 

        var t_baker; // date de préparation supposé dans le fichier qui correspond au nom et date de publication dans le fichier suivant(c'est à ce moment qu'il est visible pour les délégués)
        var t_recep; // date de réception du bloc 

        function range(start, end) {
            var ans = [];
            for (let i = start; i <= end; i++) {
                ans.push(+i);
            }
            return ans;
        }

        function onlyUnique(value, index, self) {
            return self.indexOf(value) === index;
        }

        $.get(server_adress, null, function (text) {
            //directories=$(text).find("a").text(); //fonctionne !!! 
            $(text).find("a").each(function () {
                let s = $(this).text();
                //console.log(typeof(s));
                if (s.includes('-') == true) {
                    //console.log(s);
                    var minmax = s.split('-');
                    if (+minmax[0] > 0 && +minmax[1] > 0) { // filtrer les autres fichiers 
                        directories[s] = [+minmax[0], +minmax[1]]
                    }


                }
            })
        })

        function ComputeGamma(beg, end, t_cibles) {

            t_op_retard = {}; // contient plusieurs dict, chacun associé à un round/type(preendo ou endo)
            t_op_valide = {}; // t_op_erreur[k]= t_op_erreur_i
            t_op_pre_retard = {}; // contient plusieurs dict, chacun associé à un round/type(preendo ou endo)
            t_op_pre_valide = {}; // contient plusieurs dict, chacun associé à un round. Ces dict contiennent 2 listes, qui sont les délais de réception pour les Préendorsement et les endorsmenet invalides 

            //let t_cibles = range(time_low, time_high);
            new Promise((resolve, reject) => {
                var range_bloc = range(beg, end);

                range_bloc.forEach((a) => {


                    Object.entries(directories).forEach(([k, v]) => {

                        if ((+a) <= v[1] && (+a) >= v[0]) {
                            try {
                                $.getJSON(server_adress + "/" + k + "/" + a + ".json", null, function (json_data) {
                                    //console.log(server_adress + "/" + k + "/" + a + ".json");
                                    dict_data[a] = json_data;
                                    //console.log(dict_data[a]);

                                })
                            } catch {
                                //console.log("bloc: " + a + " est introuvable");
                            }
                        }
                    })




                })

                Object.entries(dict_data).forEach(([k, v]) => {


                    var t_op_retard_i = {}; // contient plusieurs dict, chacun associé à un round/type(preendo ou endo)
                    var t_op_valide_i = {}; // t_op_erreur[k]= t_op_erreur_i
                    var t_op_pre_retard_i = {}; // contient plusieurs dict, chacun associé à un round/type(preendo ou endo)
                    var t_op_pre_valide_i = {}; // t_op_erreur[k]= t_op_erreur_i

                    var va = k;
                    var va_1 = (parseInt(k) + 1) + "";//#block+1
                    var round_bloc; // round final du bloc
                    var t_baker = {}; // date de préparation supposé dans le fichier qui correspond au nom et date de publication dans le fichier suivant(c'est à ce moment qu'il est visible pour les délégués)
                    var t_recep; // date de réception du bloc 

                    try {
                        let r = dict_data[va]["blocks"].length;
                        if (r == 1) {
                            if ("round" in dict_data[va]["blocks"][0]) {
                                t_baker[dict_data[va]["blocks"][0]["round"]] = new Date(dict_data[va]["blocks"][0]["timestamp"]);//date de baking <= timestamps est la date de baking ! a corriger 
                                //console.log("date supposé de baking: " + t_baker);

                            } else {
                                t_baker[0] = new Date(dict_data[va]["blocks"][0]["timestamp"]);//date de baking <= timestamps est la date de baking ! a corriger 
                                //console.log("date supposé de baking: " + t_baker);
                            }
                        }
                        else {

                            (dict_data[va]["blocks"]).forEach((element) => {
                                if (typeof element["round"] !== "undefined") {
                                    t_baker[element["round"]] = new Date(element["timestamp"]);
                                } else {
                                    t_baker[0] = new Date(element["timestamp"]);
                                }

                            })

                        }
                        //console.log(t_baker);
                    }
                    catch (error) {
                        //console.log(error);
                    }


                    try {
                        round_bloc = + dict_data[va]["blocks"][0]["round"];//Si pas de retour => round0
                        if (isNaN(round_bloc)) {
                            round_bloc = 0;

                        }
                        //console.log("Le nombre final de round du bloc est: " + round_bloc);
                    }
                    catch {
                        round_bloc = 0;
                    }

                    for (let i = 0; i <= round_bloc; i++) {

                        t_op_retard_i[i] = []; //Memo: Les retards concernent que les preendos?Faire pour les deux: ils sont soit dans le fichier #bloc( kind: temporary, round>0, "expected_max": round-1) fichiers suivant (pour voir si ça correspond à ce qu'on veut, on peut regarder: si expected est dans erreur, si expected= bloc, si kind= temporary)
                        t_op_valide_i[i] = []; // t_op_valide[i][t_approbations]
                        t_op_pre_retard_i[i] = [];
                        t_op_pre_valide_i[i] = [];//t_op_valide[i][t_pre_approbations]

                    }



                    if (round_bloc > 0) { // Si les éléments de chaque round sont indiqués dans le fichier 

                        Object.entries(dict_data[va]["endorsements"]).forEach(([k, v]) => {
                            //console.log(v); // array avec delegate et OP

                            try { //traitement des blocs avec block round > 0 et payload round = 0                                      
                                //console.log((v["operations"]).length);
                                if ("operations" in v) {
                                    for (let i = 0; i < (v["operations"]).length; i++) {
                                        round_cib = v["operations"][i]["round"];
                                        if ("errors" in v["operations"][i]) { // L'OP n'est pas valide ?
                                            //console.log(v["operations"][i]["errors"]);


                                            if ("expected_max" in v["operations"][i]["errors"][0]) {

                                                if (("kind" in v["operations"][i])) { // preendo  if (round_cib != round_bloc) { <= aller chercher round cib


                                                    if (v["operations"][i]["errors"][0]["kind"] == "temporary") {


                                                        if (round_cib in t_baker) {


                                                            if (("reception_time" in v["operations"][i])) {



                                                                if (v["operations"][i]["reception_time"] != null) {
                                                                    //console.log("A");

                                                                    //ajouter à t_op_error[retard][t_preendo]
                                                                    //console.log(t_baker[round_cib]);
                                                                    //console.log(v["operations"][i]["reception_time"]);
                                                                    //console.log();
                                                                    t_op_pre_retard_i[v["operations"][i]["errors"][0]["expected_max"]].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                                    ////ano_desc[round_cib]["pre_approbations"]["invalide"].push([v["delegate"], v["operations"][i]["errors"][0]["id"]])
                                                                }
                                                            }
                                                        }

                                                    }



                                                }
                                                else {//endo

                                                    if (v["operations"][i]["errors"][0]["kind"] == "temporary") {
                                                        if (round_cib in t_baker) {
                                                            if (("reception_time" in v["operations"][i])) {
                                                                if (v["operations"][i]["reception_time"] != null) {
                                                                    //ajouter à t_op_error[retard][t_preendo]
                                                                    t_op_retard_i[v["operations"][i]["errors"][0]["expected_max"]].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                                    ////ano_desc[round_cib]["pre_approbations"]["invalide"].push([v["delegate"], v["operations"][i]["errors"][0]["id"]])
                                                                }
                                                            }
                                                        }

                                                    }

                                                }
                                            }

                                        }
                                        else { //L'OP est valide ?

                                            if (("kind" in v["operations"][i])) { // preendo  if (round_cib != round_bloc) { <= aller chercher round cib
                                                if (("reception_time" in v["operations"][i]) && ("round" in v["operations"][i])) {
                                                    //console.log(v["operations"][i]["reception_time"])
                                                    if (round_cib in t_baker) {
                                                        if (v["operations"][i]["reception_time"] != null) {
                                                            //ajouter à t_op_valide[round_bloc][t_preendo]
                                                            t_op_pre_valide_i[round_cib].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                            //console.log("passe");
                                                            ////ano_desc[round_cib]["pre_approbations"]["valide"].push(v["delegate"]);
                                                            //console.log("PRE APPRO VALIDE");
                                                            //console.log(v["operations"][i]);

                                                        }
                                                    }
                                                }
                                            }
                                            else {//endo

                                                if (("reception_time" in v["operations"][i]) && ("round" in v["operations"][i])) {
                                                    //console.log(v["operations"][i]["reception_time"])
                                                    if (round_cib in t_baker) {
                                                        if (v["operations"][i]["reception_time"] != null) {
                                                            //ajouter à t_op_valide[round_bloc][t_preendo]
                                                            t_op_valide_i[round_cib].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                            //console.log("passe");
                                                            ////ano_desc[round_cib]["pre_approbations"]["valide"].push(v["delegate"]);
                                                            //console.log("PRE APPRO VALIDE");
                                                            //console.log(v["operations"][i]);

                                                        }
                                                    }
                                                }

                                            }
                                        }
                                    }
                                }
                            } catch (error) {

                                console.log(error);

                            }

                            /*console.log("t_op_pre_retard_i");
                        console.log(t_op_pre_retard_i);
                        console.log("t_op_valide_i");
                        console.log(t_op_valide_i);
                        console.log("t_op_retard_i");
                        console.log(t_op_retard_i);
                        console.log("t_op_pre_valide_i");
                        console.log(t_op_pre_valide_i);*/

                            t_op_pre_retard[va] = t_op_pre_retard_i;
                            t_op_pre_valide[va] = t_op_pre_valide_i;
                            t_op_retard[va] = t_op_retard_i;
                            t_op_valide[va] = t_op_valide_i;



                        });

                        //On commence la recherche des retards dans le bloc suivant ici, (pour voir si ça correspond à ce qu'on veut, on peut regarder: si expected est dans erreur, si expected= bloc, si kind= temporary)

                        Object.entries(directories).forEach(([k, v]) => {

                            if ((+va_1) <= v[1] && (+va_1) >= v[0]) {
                                //console.log("The key: ", k);
                                //console.log("min: ", v[0]);
                                //console.log("max: ", v[1]);
                                $.getJSON(server_adress + "/" + k + "/" + va_1 + ".json", null, function (json_data) { //traitement du reste
                                    var item_i = [];
                                    dict_data[va_1] = json_data
                                    //console.log(t_baker);
                                    try { // traitement de l'info du fichier correspondant au bloc
                                        //Info relatives aux (pre)approbations valides du bloc va
                                        Object.entries(dict_data[va_1]["endorsements"]).forEach(([k, v]) => {
                                            try {
                                                //console.log(v);
                                                if ("operations" in v) {
                                                    for (let i = 0; i < v["operations"].length; i++) {//
                                                        if ((("errors" in v["operations"][i]))) { //dès lors qu'on trouve une erreur, on vérifier qu'il s'agit d'une erreur concernant le block ciblé(va) et son round.
                                                            if (v["operations"][i]["errors"][0]["kind"] == "temporary") {
                                                                var block_cib = (v["operations"][i]["errors"][0]["expected"]) + "";
                                                                var round_cib = v["operations"][i]["round"];
                                                                if (block_cib == va) {
                                                                    //console.log(v["operations"]);
                                                                    //console.log(round_cib);
                                                                    if (round_cib in t_baker) {
                                                                        if ("kind" in v["operations"][i]) { // c'est un preendo
                                                                            t_op_pre_retard_i[round_cib].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                                        }
                                                                        else {
                                                                            //console.log(v["operations"][i]["errors"][0]["expected_max"]);
                                                                            t_op_retard_i[round_cib].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                                        }
                                                                    }
                                                                }

                                                            }
                                                        }

                                                    }
                                                }

                                            }
                                            catch (error) {
                                                console.log(error); // endo manqués
                                            }
                                        });

                                    }
                                    catch (error) {
                                        console.log(error);
                                    }
                                });
                            }
                        });

                        /*console.log("t_op_pre_retard_i");
                        console.log(t_op_pre_retard_i);
                        console.log("t_op_valide_i");
                        console.log(t_op_valide_i);
                        console.log("t_op_retard_i");
                        console.log(t_op_retard_i);
                        console.log("t_op_pre_valide_i");
                        console.log(t_op_pre_valide_i);*/

                        t_op_pre_retard[va] = t_op_pre_retard_i;
                        t_op_pre_valide[va] = t_op_pre_valide_i;
                        t_op_retard[va] = t_op_retard_i;
                        t_op_valide[va] = t_op_valide_i;


                    }//fin du if

                    else { // en chantier !! 
                        //console.log("Block round=0")

                        Object.entries(dict_data[va]["endorsements"]).forEach(([k, v]) => {
                            //console.log(v); // array avec delegate et OP

                            try { //traitement des blocs avec block round > 0 et payload round = 0                                      
                                //console.log((v["operations"]).length);
                                for (let i = 0; i < (v["operations"]).length; i++) {
                                    round_cib = v["operations"][i]["round"];
                                    if ("errors" in v["operations"][i]) { // L'OP n'est pas valide ?
                                        //console.log(v["operations"][i]["errors"]);
                                        if ("provided" in v["operations"][i]["errors"][0]) {
                                            //console.log("provided");
                                            if (v["operations"][i]["errors"][0]["provided"] == 1 | v["operations"][i]["errors"][0]["provided"] == 0) {
                                                //console.log("provided=1");
                                                //L'erreur concerne le bloc


                                                if (("kind" in v["operations"][i])) { // preendo  if (round_cib != round_bloc) { <= aller chercher round cib
                                                    if (round_bloc == round_cib) {
                                                        if (round_cib in t_baker) {

                                                            if (("reception_time" in v["operations"][i])) {
                                                                if (v["operations"][i]["reception_time"] != null) {
                                                                    //ajouter à t_op_error[retard][t_preendo]
                                                                    t_op_erreur["retard"]["t_pre_approbations"].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                                    //ano_desc[round_cib]["pre_approbations"]["invalide"].push([v["delegate"], v["operations"][i]["errors"][0]["id"]])
                                                                }
                                                            }

                                                        }
                                                    }
                                                    else {
                                                        //console.log

                                                        if (("reception_time" in v["operations"][i])) {
                                                            if (v["operations"][i]["reception_time"] != null) {
                                                                //ajouter à t_op_erreur[round_cib][t_preendo]
                                                                if (round_cib in t_baker) {
                                                                    t_op_erreur[round_cib]["t_pre_approbations"].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                                    //ano_desc[round_cib]["pre_approbations"]["invalide"].push([v["delegate"], v["operations"][i]["errors"][0]["id"]])
                                                                }
                                                            }


                                                        }

                                                    }


                                                }
                                                else {//endo
                                                    if (round_cib in t_baker) {
                                                        if (round_bloc == round_cib) {

                                                            if (("reception_time" in v["operations"][i])) {
                                                                if (v["operations"][i]["reception_time"] != null) {


                                                                    if (("included_in_blocks" in v["operations"][i])) {
                                                                        //t_op_error[retard][t_endo]
                                                                        t_op_erreur["retard"]["t_approbations"].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                                        //ano_desc[round_cib]["approbations"]["invalide"].push([v["delegate"], v["operations"][i]["errors"][0]["id"]])


                                                                    }



                                                                }

                                                            }

                                                        }
                                                        else {

                                                            if (("reception_time" in v["operations"][i])) {
                                                                if (v["operations"][i]["reception_time"] != null) {
                                                                    //ajouter à t_op_erreur[round_cib][t_endo]
                                                                    t_op_erreur[round_cib]["t_approbations"].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                                    //ano_desc[round_cib]["approbations"]["invalide"].push([v["delegate"], v["operations"][i]["errors"][0]["id"]]);


                                                                }


                                                            }
                                                        }

                                                    }
                                                }









                                            }

                                        }

                                    }
                                    else { //L'OP est valide ?
                                        if (round_cib in t_baker) {
                                            if (("kind" in v["operations"][i])) { // preendo  if (round_cib != round_bloc) { <= aller chercher round cib
                                                if (round_bloc == round_cib) {

                                                    if (("reception_time" in v["operations"][i])) {
                                                        //console.log(v["operations"][i]["reception_time"])
                                                        if (v["operations"][i]["reception_time"] != null) {
                                                            //ajouter à t_op_valide[round_bloc][t_preendo]
                                                            //console.log(new Date(v["operations"][i]["reception_time"]));
                                                            //console.log(t_baker);
                                                            t_op_pre_valide_i[round_cib].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                            //ano_desc[round_cib]["pre_approbations"]["valide"].push(v["delegate"]);
                                                            //console.log("PRE APPRO VALIDE");
                                                            //console.log(v["operations"][i]);

                                                        }
                                                        else {
                                                            //console.log("date de récep pas dispo");
                                                            //console.log(v["operations"][i]);
                                                            //ano_desc[round_cib]["pre_approbations"]["inconnu"].push([v["delegate"], "pas d'erreur + date de recep null"]);
                                                            //ano_desc[round_cib]["pre_approbations"]["valide"].push(v["delegate"]);


                                                            //date de récep pas dispo
                                                        }

                                                    } else {
                                                        // jamais reçu => Manquées
                                                        //console.log("jamais reçu => Manquées");
                                                        //console.log(v["operations"][i]);
                                                        //ano_desc[round_cib]["pre_approbations"]["sequestre"].push(v["delegate"]);

                                                    }

                                                }
                                                else {

                                                    if (("reception_time" in v["operations"][i])) {
                                                        //console.log(v["operations"][i]["reception_time"])
                                                        if (v["operations"][i]["reception_time"] != null) {
                                                            //ajouter à t_op_valide[round_cib][t_preendo]
                                                            t_op_pre_valide_i[round_cib].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                            //ano_desc[round_cib]["pre_approbations"]["valide"].push(v["delegate"]);
                                                        }
                                                        else {
                                                            //date de récep pas dispo et valide
                                                            //ano_desc[round_cib]["pre_approbations"]["inconnu"].push([v["delegate"], "pas d'erreur + date de recep null"]);
                                                            //ano_desc[round_cib]["pre_approbations"]["valide"].push(v["delegate"]);

                                                        }

                                                    } else {
                                                        // jamais reçu => Manquées également 
                                                        //ano_desc[round_cib]["pre_approbations"]["sequestre"].push(v["delegate"]);
                                                    }

                                                }


                                            }
                                            else {//endo
                                                //console.log(v["operations"][i])

                                                if (round_bloc == round_cib) {

                                                    if (("reception_time" in v["operations"][i])) {
                                                        //console.log(v["operations"][i]["reception_time"])
                                                        if (v["operations"][i]["reception_time"] != null) {


                                                            if (("included_in_blocks" in v["operations"][i])) {
                                                                //t_op_valide[round_bloc][t_endo]
                                                                t_op_valide_i[round_cib].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                                //ano_desc[round_cib]["approbations"]["valide"].push(v["delegate"]);


                                                            }
                                                            else {
                                                                //console.log("Pas d'inclusion au bloc => Approbation oubliée");
                                                                //ano_desc[round_cib]["approbations"]["oublie"].push(v["delegate"]);

                                                                //console.log(v["operations"]);
                                                            }


                                                        }
                                                        else {
                                                            //date de récep pas dispo
                                                            //ano_desc[round_cib]["approbations"]["inconnu"].push([v["delegate"], "pas d'erreur + date de recep null"]);
                                                            //ano_desc[round_cib]["approbations"]["valide"].push(v["delegate"]);
                                                        }
                                                    }

                                                    else {
                                                        // jamais reçu => Manquées
                                                        //ano_desc[round_cib]["approbations"]["sequestre"].push(v["delegate"]);
                                                    }

                                                }
                                                else {

                                                    if (("reception_time" in v["operations"][i])) {
                                                        //console.log(v["operations"][i]["reception_time"])
                                                        if (v["operations"][i]["reception_time"] != null) {
                                                            //ajouter à t_op_valide[round_cib][t_endo]
                                                            t_op_pre_valide_i[round_cib].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                            //ano_desc[round_cib]["approbations"]["valide"].push(v["delegate"]);

                                                        }
                                                        else {
                                                            //date de récep pas dispo
                                                            //ano_desc[round_cib]["approbations"]["inconnu"].push([v["delegate"], "pas d'erreur + date de recep null"]);
                                                            //ano_desc[round_cib]["approbations"]["valide"].push(v["delegate"]);

                                                        }

                                                    } else {
                                                        //console.log("jamais reçu => Manquées également");
                                                        //ano_desc[round_cib]["approbations"]["sequestre"].push(v["delegate"]);

                                                    }

                                                }


                                            }
                                        }
                                    }
                                }


                            } catch (error) {
                                //ano_desc["0"]["approbations"]["manque"].push(v["delegate"]);
                                //console.log("ce sont des manqués");
                                //console.log(k);
                                //console.log(v);

                            }

                        });

                        Object.entries(directories).forEach(([k, v]) => {

                            if ((+va_1) <= v[1] && (+va_1) >= v[0]) {
                                //console.log("The key: ", k);
                                //console.log("min: ", v[0]);
                                //console.log("max: ", v[1]);
                                $.getJSON(server_adress + "/" + k + "/" + va_1 + ".json", null, function (json_data) { //traitement du reste
                                    var item_i = [];
                                    dict_data[va_1] = json_data
                                    //console.log(t_baker);
                                    try { // traitement de l'info du fichier correspondant au bloc
                                        //Info relatives aux (pre)approbations valides du bloc va
                                        Object.entries(dict_data[va_1]["endorsements"]).forEach(([k, v]) => {
                                            try {
                                                if ("operations" in v) {
                                                    for (let i = 0; i < (v["operations"]).length; i++) {//
                                                        if ((("errors" in v["operations"][i]))) { //dès lors qu'on trouve une erreur, on vérifier qu'il s'agit d'une erreur concernant le block ciblé(va) et son round.
                                                            if (v["operations"][i]["errors"][0]["kind"] == "temporary") {
                                                                //console.log(v["operations"][i]["errors"][0]["expected"], typeof (v["operations"][i]["errors"][0]["expected"]));

                                                                var block_cib = v["operations"][i]["errors"][0]["expected"] + "";
                                                                var round_cib = v["operations"][i]["round"];
                                                                if (round_cib in t_baker) {
                                                                    if (block_cib == va) {
                                                                        if ("kind" in v["operations"][i]) { // c'est un preendo
                                                                            //console.log(t_baker[round_cib]);
                                                                            //console.log(v["operations"][i]["reception_time"]);
                                                                            t_op_pre_retard_i[round_cib].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                                        }
                                                                        else {
                                                                            t_op_retard_i[round_cib].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                                        }
                                                                    }
                                                                }

                                                            }
                                                        }

                                                    }
                                                }
                                            }
                                            catch (e) {
                                                console.log(e);
                                            }



                                        });

                                    }
                                    catch (error) {
                                        console.log(error);
                                    }




                                }


                                );
                            }
                        });


                        t_op_pre_retard[va] = t_op_pre_retard_i;
                        t_op_pre_valide[va] = t_op_pre_valide_i;
                        t_op_retard[va] = t_op_retard_i;
                        t_op_valide[va] = t_op_valide_i;



                    }

                });
                resolve(t_op_pre_valide)
            }).then(resolve => {
                console.log(resolve)



                try {

                    console.log(t_cibles)
                    var t_pI = [];
                    new Promise((resolve, reject) => { //Qd besoin de sync : https://www.freecodecamp.org/news/synchronous-vs-asynchronous-in-javascript/

                        t_cibles.forEach(t_cible => {
                            var pI_level = {};
                            var l_rounds = [];
                            Object.entries(t_op_pre_valide).forEach(([bloc, v_bloc]) => {
                                pI_level[bloc] = {};
                                Object.entries(v_bloc).forEach(([level, v_level]) => {
                                    l_rounds.push(level);
                                    var card_valide_tcible = 0;
                                    //pI_level[bloc][level]=
                                    for (const element of v_level) {
                                        if (element <= t_cible) {
                                            card_valide_tcible += 1;
                                        }
                                        //pI_level[bloc][level]= (card_valide_tcible/(v_level.length + t_op_pre_retard[bloc][level].length))
                                    }

                                    //console.log(bloc);
                                    //console.log(level);
                                    //console.log(v_level);
                                    //console.log(card_valide_tcible);
                                    if (isNaN(card_valide_tcible / (v_level.length + t_op_pre_retard[bloc][level].length)) == false) {
                                        pI_level[bloc][level] = (card_valide_tcible / (v_level.length + t_op_pre_retard[bloc][level].length))
                                    }
                                })

                            });

                            l_rounds = l_rounds.filter(onlyUnique);
                            //console.log("l_rounds: ", l_rounds);
                            //t_pI[t_cible] = {};
                            for (const r in l_rounds) {
                                var pi_l = [];
                                Object.entries(pI_level).forEach(([level, v_level]) => {
                                    if (r in v_level) {
                                        pi_l.push(v_level[r]);
                                    }

                                });
                                //console.log(r, pi_l);
                                t_pI.push({ temps: +t_cible, round: r, value: (pi_l.reduce((a, b) => a + b, 0) / pi_l.length) });
                            }
                        });
                        resolve(t_pI)
                    }).then(resolve => {
                        chart_gamma(resolve);
                        console.log("Gamma: ", resolve);
                    })
                } catch (e) {
                    console.log(e)
                }
            })


        }

        function chart_gamma(data) {
            var margin = ({ top: 40, right: 180, bottom: 30, left: 40 }),
                width = 850 - margin.left - margin.right;//1000, // outer width of chart, in pixels
            height = 500 - margin.top - margin.bottom;//400; // outer height of chart, in pixels 
            try {
                try {
                    while (document.getElementById("gamma").querySelector("svg")) {
                        const elements3 = document.getElementById("gamma").querySelector("svg");
                        document.getElementById("gamma").removeChild(elements3);
                    }
                } catch (e) {
                    console.log(e)
                }
                const svg = d3.select("body").select("#gamma").append("svg")
                    .attr("width", width + margin.left + margin.right)
                    .attr("height", height + margin.top + margin.bottom);

                const svgg = svg.append("g")
                    .attr("transform",
                        "translate(" + margin.left + "," + margin.top + ")");


                // Not much changes here with the original function
                // group makes it a little easier, just pass the data and a function that
                // tells you how to get each key. Instead of returning a nest object it returns
                // a javascript Map. We can still iterate over maps as we'll see in a bit.
                //var sumstat = d3.nest() // nest function allows to group the calculation per level of a factor
                //  .key(function(d) { return d.name;})
                //  .entries(data);

                var sumstat = d3.group(data, d => d.round);

                // Add X axis --> it is a date format
                var x = d3.scaleLinear()
                    .domain(d3.extent(data, d => d.temps))
                    .range([0, width]);
                svgg.append("g")
                    .attr("transform", "translate(0," + height + ")")
                    .call(d3.axisBottom(x).ticks(5));

                // Add Y axis
                var y = d3.scaleLinear()
                    .domain([0, 100])
                    .range([height, 0]);
                svgg.append("g")
                    .attr("transform", "translate(0,0)")
                    .call(d3.axisLeft(y).tickSizeOuter(0));

                // color palette
                var res = Array.from(sumstat.keys()); // list of group names
                var color = d3.scaleOrdinal()
                    .domain(res)
                    .range(['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#ffff33', '#a65628', '#f781bf', '#999999'])

                var legend = d3.legendColor().scale(color);

                svgg.append("g").attr("transform", "translate(" + (width) + ",10)").call(legend);

                // This is where things change a bit. First rather than use the append().enter() pattern we're going
                // to use the new 'join' pattern, it's a bit cleaner. Next all we have to realize is that instead of 
                // getting an array of objects have a `key` and `values` properties, it's going to be a length two 
                // array with the key being the first entry and the rest of the data as the second.
                svgg.selectAll(".line")
                    .data(sumstat)
                    .join("path")
                    .attr('fill', 'none')
                    .attr('stroke-width', 1.5)
                    .attr('stroke', d => color(d[0]))
                    .attr("d", d => {
                        return d3.line()
                            .x(d => x(d.temps))
                            .y(d => y(100 * d.value))
                            (d[1])
                    });

                svgg.append("text")
                    .attr("x", -margin.left + 40)
                    .attr("y", -5)
                    .attr("fill", "currentColor")
                    .attr("text-anchor", "start")
                    .text("↑ % Preendorsements received before threshold time");

                svgg.append("text")
                    .attr("x", width + margin.right)
                    .attr("y", height)
                    .attr("fill", "currentColor")
                    .attr("text-anchor", "end")
                    .text(" threshold time (seconds) →");

                svgg.append("text")
                    .attr("x", width + 40)
                    .attr("y", 0)
                    .attr("fill", "currentColor")
                    .attr("text-anchor", "end")
                    .text("Level:");


            } catch (e) { console.log(e) }

        }


        try {
            $.get(server_adress, null, function (text) {
                //directories=$(text).find("a").text(); //fonctionne !!! 
                $(text).find("a").each(function () {
                    let s = $(this).text();
                })



                /*
                $('form').keyup(function (e) {

                    //document.getElementById('launch').onclick = function() {

                    beg_ = document.getElementById('selectedLevel_begin').value;
                    end_ = document.getElementById('selectedLevel_end').value;
                    threshold_low = document.getElementById('selectedThreshold_beg').value;
                    threshold_high = document.getElementById('selectedThreshold_end').value;

                    ComputeGamma(beg_, end_, threshold_low, threshold_high);


                    var comment = document.getElementsByClassName("getElementBy");
                    for (var i = 0; i < comment.length; i++) {
                        comment[i].addEventListener("keydown", function () {
                            beg_ = document.getElementById('selectedLevel_begin').value;
                            end_ = document.getElementById('selectedLevel_end').value;
                            threshold_low = document.getElementById('selectedThreshold_beg').value;
                            threshold_high = document.getElementById('selectedThreshold_end').value;
                            ComputeGamma(beg_, end_, threshold_low, threshold_high);
                        })
                    }

                    //};
                });
                */

                $('#submit_').mouseup(function (e) {

                    //document.getElementById('launch').onclick = function() {

                    beg_ = document.getElementById('selectedLevel_begin').value;
                    end_ = document.getElementById('selectedLevel_end').value;
                    threshold_low = document.getElementById('selectedThreshold_beg').value;
                    console.log(threshold_low);
                    threshold_high = document.getElementById('selectedThreshold_end').value;
                    console.log(threshold_high);
                    const range_t = range(+threshold_low, +threshold_high);

                    ComputeGamma(beg_, end_, range_t);


                    /*var comment = document.getElementsByClassName("getElementBy");
                    for (var i = 0; i < comment.length; i++) {
                        comment[i].addEventListener("keydown", function () {
                            beg_ = document.getElementById('selectedLevel_begin').value;
                            end_ = document.getElementById('selectedLevel_end').value;
                            threshold_low = document.getElementById('selectedThreshold_beg').value;
                            threshold_high = document.getElementById('selectedThreshold_end').value;
                            ComputeGamma(beg_, end_, threshold_low, threshold_high);
                        })
                    }*/

                    //};
                });




                /*$('form').keyup(function (e) {
                    beg_ = document.getElementById('selectedLevel_begin').value;
                    end_ = document.getElementById('selectedLevel_end').value;
                    threshold_ = document.getElementById('selectedThreshold').value;
                    ComputeAlpha(beg_, end_, threshold_);
                    });*/
            })
        } catch (e) {
            console.log(e)
        }
    </script>