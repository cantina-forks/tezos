<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Adress Endorsement reception delays</title>
    <script src=https://cdnjs.cloudflare.com/ajax/libs/mathjs/3.3.0/math.min.js></script>
    <script src="https://cdn.jsdelivr.net/npm/d3@7.4.4/dist/d3.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-legend/2.13.0/d3-legend.js"></script>
</head>

<body>
    <h1> Adress Endorsement reception delays </h1>
    <form>
        <div>
            <label for="selectedLevel_begin">First bloc:</label>
            <input name="level_" id="selectedLevel_begin" type="number" value="2497000" />
            <span id='tick_begin'></span>
            <br>
            <label for="selectedLevel_end">Last bloc:</label>
            <input name="level_" id="selectedLevel_end" type="number" value="2497100" />
            <span id='tick_end'></span>
            <br>
            <label for="adress_">adresse:</label>
            <input name="adress_" id="adress_" type="string" value="tz1VQnqCCqX4K5sP3FNkVSNKTdCAMJDd3E1n" />
            <input type="button" id="submit_" value="Rechercher ">

        </div>
    </form>
    <script>
        var dict_data = {};
        const server_adress = "http://78.193.200.52";
        var directories = {};
        var t_op_valide = { "timestamp": { "endo": {}, "preendo": {} }, "reception": { "endo": {}, "preendo": {} } }; // contient plusieurs dict, chacun associé à un round. Ces dict contiennent 2 listes, qui sont les délais de réception pour les Préendorsement et les endorsmenet valides 
        var return_t_op_valide = []
        var t_op_retard = { "timestamp": { "endo": {}, "preendo": {} }, "reception": { "endo": {}, "preendo": {} } }; // 
        var missed_block = [];
        var return_missed = [];
        var op_sequestre = [];
        var op_oublies = [];
        var baker;
        var t_baker = {}; // date de préparation supposé dans le fichier qui correspond au nom et date de publication dans le fichier suivant(c'est à ce moment qu'il est visible pour les délégués)
        var t_recep = {}; // date de réception du bloc 
        var t_delai_bloc = {};
        var round_bloc; // round final du bloc
        var ano_desc = {}; // COntient les différentes catégories d'opérations, ainsi qu'une liste des délégué associé aux op de chaque catégorie

        function range(start, end) {
            var ans = [];
            for (let i = start; i <= end; i++) {
                ans.push(i);
            }
            return ans;
        }

        function onlyUnique(value, index, self) {
            return self.indexOf(value) === index;
        }

        $.get(server_adress, null, function (text) {
            //directories=$(text).find("a").text(); //fonctionne !!! 
            $(text).find("a").each(function () {
                let s = $(this).text();
                //console.log(typeof(s));
                if (s.includes('-') == true) {
                    //console.log(s);
                    var minmax = s.split('-');
                    if (+minmax[0] > 0 && +minmax[1] > 0) { // filtrer les autres fichiers 
                        directories[s] = [+minmax[0], +minmax[1]]
                    }


                }
            })
        })

        function Resume_OP_cons_adress(beg, end, adress) {

            var range_bloc = range(beg, end);

            range_bloc.forEach((a) => {


                Object.entries(directories).forEach(([k, v]) => {

                    if ((+a) <= v[1] && (+a) >= v[0]) {
                        try {
                            $.getJSON(server_adress + "/" + k + "/" + a + ".json", null, function (json_data) {
                                //console.log(server_adress + "/" + k + "/" + a + ".json");
                                dict_data[a] = json_data;
                                //console.log(dict_data[a]);

                            })
                        } catch {
                            console.log("bloc: " + a + " est introuvable");
                        }
                    }
                })




            })

            t_op_valide = { "timestamp": { "endo": {}, "preendo": {} }, "reception": { "endo": {}, "preendo": {} } }; // contient plusieurs dict, chacun associé à un round. Ces dict contiennent 2 listes, qui sont les délais de réception pour les Préendorsement et les endorsmenet valides 
            t_op_retard = { "timestamp": { "endo": {}, "preendo": {} }, "reception": { "endo": {}, "preendo": {} } }; // 
            missed_block = [];
            op_sequestre = [];
            op_oublies = [];


            Object.entries(dict_data).forEach(([k, v]) => {
                var va = k;
                var va_1 = (parseInt(k) + 1).toString();//#block+1
                var round_bloc; // round final du bloc
                var t_baker = {}; // date de préparation supposé dans le fichier qui correspond au nom et date de publication dans le fichier suivant(c'est à ce moment qu'il est visible pour les délégués)
                var t_recep = {}; // date de réception du bloc 


                try {
                    let r = dict_data[va]["blocks"].length;
                    if (r == 1) {
                        if ("round" in dict_data[va]["blocks"][0]) {
                            t_baker[dict_data[va]["blocks"][0]["round"]] = new Date(dict_data[va]["blocks"][0]["timestamp"]);//date de baking <= timestamps est la date de baking ! a corriger 
                            //console.log("date supposé de baking: " + t_baker);

                        } else {
                            t_baker[0] = new Date(dict_data[va]["blocks"][0]["timestamp"]);//date de baking <= timestamps est la date de baking ! a corriger 
                            //console.log("date supposé de baking: " + t_baker);
                        }
                    }
                    else {

                        (dict_data[va]["blocks"]).forEach((element) => {
                            if (typeof element["round"] !== "undefined") {
                                t_baker[element["round"]] = new Date(element["timestamp"]);
                            } else {
                                t_baker[0] = new Date(element["timestamp"]);
                            }

                        })

                    }
                    //console.log(t_baker);
                }
                catch (error) {
                    //console.log(error);
                }

                try {
                    let r = dict_data[va]["blocks"].length;
                    if (r == 1) {
                        if ("round" in dict_data[va]["blocks"][0]) {
                            t_recep[dict_data[va]["blocks"][0]["round"]] = new Date(dict_data[va]["blocks"][0]["reception_time"]);//date de réception 
                            //console.log("date supposé de réception: " + t_recep);

                        } else {
                            t_recep[0] = new Date(dict_data[va]["blocks"][0]["reception_time"]);//date de réception <
                            //console.log("date supposé de réception: " + t_recep);
                        }
                    }
                    else {

                        (dict_data[va]["blocks"]).forEach((element) => {
                            if (typeof element["round"] !== "undefined") {
                                t_recep[element["round"]] = new Date(element["reception_time"]);
                            } else {
                                t_recep[0] = new Date(element["reception_time"]);
                            }

                        })

                    }
                    //console.log(t_baker);
                }
                catch (error) {
                    //console.log(error);
                }

                try {
                    round_bloc = + dict_data[va]["blocks"][0]["round"];//Si pas de retour => round0
                    if (isNaN(round_bloc)) {
                        round_bloc = 0;

                    }
                    //console.log("Le nombre final de round du bloc est: " + round_bloc);
                }
                catch {
                    round_bloc = 0;
                }
                const get_res = new Promise((resolve) => {
                    console.log(dict_data);
                    if (round_bloc > 0) { // Si les éléments de chaque round sont indiqués dans le fichier 

                        Object.entries(dict_data[va]["endorsements"]).forEach(([k, v]) => {
                            //console.log(v); // array avec delegate et OP
                            if (v['delegate'] == adress) { //s'il s'agit du délégué visé 
                                //console.log("fonctionne");
                                try { //traitement des blocs avec block round > 0 et payload round = 0                                      
                                    //console.log((v["operations"]).length);
                                    if ("operations" in v) {
                                        var participation_in_round = [];
                                        for (let i = 0; i < (v["operations"]).length; i++) {

                                            round_cib = v["operations"][i]["round"];
                                            participation_in_round.push(round_cib);
                                            if ("errors" in v["operations"][i]) { // L'OP n'est pas valide ?
                                                //console.log(v["operations"][i]["errors"]);


                                                if ("expected_max" in v["operations"][i]["errors"][0]) {

                                                    if (("kind" in v["operations"][i])) { // preendo  if (round_cib != round_bloc) { <= aller chercher round cib


                                                        if (v["operations"][i]["errors"][0]["kind"] == "temporary") {


                                                            if (round_cib in t_baker) {


                                                                if (("reception_time" in v["operations"][i])) {



                                                                    if (v["operations"][i]["reception_time"] != null) {
                                                                        console.log("A");

                                                                        //ajouter à t_op_error[retard][t_preendo]
                                                                        //console.log(t_baker[round_cib]);
                                                                        //console.log(v["operations"][i]["reception_time"]);
                                                                        //console.log();

                                                                        //t_op_pre_retard_i[v["operations"][i]["errors"][0]["expected_max"]].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                                        if (v["operations"][i]["errors"][0]["expected_max"] in t_op_retard["timestamp"]["preendo"]) {
                                                                            t_op_retard["timestamp"]["preendo"]["expected_max"][va] = new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds(); // 
                                                                            t_op_retard["reception"]["preendo"]["expected_max"][va] = new Date(new Date(v["operations"][i]["reception_time"]) - t_recep[round_cib]).getSeconds(); // 
                                                                        }
                                                                        else {
                                                                            t_op_retard["timestamp"]["preendo"]["expected_max"] = {};
                                                                            t_op_retard["reception"]["preendo"]["expected_max"] = {};

                                                                            t_op_retard["timestamp"]["preendo"]["expected_max"][va] = new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds(); // 
                                                                            t_op_retard["reception"]["preendo"]["expected_max"][va] = new Date(new Date(v["operations"][i]["reception_time"]) - t_recep[round_cib]).getSeconds();
                                                                        }
                                                                        ////ano_desc[round_cib]["pre_approbations"]["invalide"].push([v["delegate"], v["operations"][i]["errors"][0]["id"]])
                                                                    }
                                                                }
                                                            }

                                                        }



                                                    }
                                                    else {//endo

                                                        if (v["operations"][i]["errors"][0]["kind"] == "temporary") {
                                                            if (round_cib in t_baker) {
                                                                if (("reception_time" in v["operations"][i])) {
                                                                    if (v["operations"][i]["reception_time"] != null) {
                                                                        //ajouter à t_op_error[retard][t_preendo]

                                                                        //t_op_retard_i[v["operations"][i]["errors"][0]["expected_max"]].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());


                                                                        t_op_retard["timestamp"]["endo"][va] = new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds(); // 
                                                                        t_op_retard["reception"]["endo"][va] = new Date(new Date(v["operations"][i]["reception_time"]) - t_recep[round_cib]).getSeconds();

                                                                    }
                                                                }
                                                            }

                                                        }

                                                    }
                                                }

                                            }
                                            else { //L'OP est valide ?

                                                if (("kind" in v["operations"][i])) { // preendo  if (round_cib != round_bloc) { <= aller chercher round cib
                                                    if (("reception_time" in v["operations"][i]) && ("round" in v["operations"][i])) {
                                                        //console.log(v["operations"][i]["reception_time"])
                                                        if (round_cib in t_baker) {
                                                            if (v["operations"][i]["reception_time"] != null) {
                                                                //ajouter à t_op_valide[round_bloc][t_preendo]

                                                                //t_op_pre_valide_i[round_cib].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                                if (round_cib in t_op_valide["timestamp"]["preendo"]) {
                                                                    t_op_valide["timestamp"]["preendo"][round_cib][va] = new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds(); //
                                                                    t_op_valide["reception"]["preendo"][round_cib][va] = new Date(new Date(v["operations"][i]["reception_time"]) - t_recep[round_cib]).getSeconds(); //
                                                                } else {
                                                                    t_op_valide["timestamp"]["preendo"][round_cib] = {};
                                                                    t_op_valide["reception"]["preendo"][round_cib] = {};
                                                                    t_op_valide["timestamp"]["preendo"][round_cib][va] = new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds(); //
                                                                    t_op_valide["reception"]["preendo"][round_cib][va] = new Date(new Date(v["operations"][i]["reception_time"]) - t_recep[round_cib]).getSeconds(); //

                                                                }
                                                                //console.log("passe");
                                                                ////ano_desc[round_cib]["pre_approbations"]["valide"].push(v["delegate"]);
                                                                //console.log("PRE APPRO VALIDE");
                                                                //console.log(v["operations"][i]);

                                                            }
                                                        }
                                                    }// pas de "else", il y a pas moyen de savoir si un preendo est oublié
                                                }
                                                else {//endo

                                                    if (("reception_time" in v["operations"][i]) && ("round" in v["operations"][i])) {
                                                        //console.log(v["operations"][i]["reception_time"])
                                                        if ("included_in_blocks" in v["operations"][i]) {
                                                            if (round_cib in t_baker) {
                                                                if (v["operations"][i]["reception_time"] != null) {
                                                                    //ajouter à t_op_valide[round_bloc][t_preendo]


                                                                    t_op_valide["timestamp"]["endo"][va] = new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds(); //
                                                                    t_op_valide["reception"]["endo"][va] = new Date(new Date(v["operations"][i]["reception_time"]) - t_recep[round_cib]).getSeconds(); //


                                                                    //console.log("passe");
                                                                    ////ano_desc[round_cib]["pre_approbations"]["valide"].push(v["delegate"]);
                                                                    //console.log("PRE APPRO VALIDE");
                                                                    //console.log(v["operations"][i]);

                                                                }
                                                            }
                                                        } else {
                                                            op_oublies.push(k);
                                                        }
                                                    }
                                                    else {
                                                        if (("included_in_blocks" in v["operations"][i]) && (!("reception_time" in v["operations"][i]))) {
                                                            op_sequestre.push(k);
                                                        }
                                                    }

                                                }
                                            }
                                        }
                                        let one = Object.keys(t_baker);
                                        console.log(one, participation_in_round)
                                        var round_missed = one.filter(function (item) { //obj :obtenir les rounds manqués par un délégué dans un bloc 
                                            console.log(item, participation_in_round.indexOf(+item) === -1);
                                            return participation_in_round.indexOf(+item) === -1;
                                        });
                                        if (round_missed.length > 0) {
                                            missed_block.push([va, round_missed]);
                                        }
                                    }
                                    else {
                                        missed_block.push([va, [-1]]);//ajouter aux manqués !!
                                    }
                                    try { // D'après Eugen, les erreurs temporaires sont provoqué par la réception d'un preendorsement avant la récep du block candidat, ils sont ensuite réévalué et considéré valides par le réseau 
                                        //console.log(v);
                                        if ("operations" in v) {
                                            for (let i = 0; i < v["operations"].length; i++) {//
                                                if ((("errors" in v["operations"][i]))) { //dès lors qu'on trouve une erreur, on vérifier qu'il s'agit d'une erreur concernant le block ciblé(va) et son round.
                                                    if (v["operations"][i]["errors"][0]["kind"] == "temporary") {
                                                        var block_cib = (v["operations"][i]["errors"][0]["provided"]).toString();
                                                        var round_cib = v["operations"][i]["round"];
                                                        if (block_cib == va) {
                                                            //console.log(v["operations"]);
                                                            //console.log(round_cib);
                                                            if (round_cib in t_baker) {
                                                                if ("kind" in v["operations"][i]) { // c'est un preendo
                                                                    if (round_cib in t_op_valide["timestamp"]["preendo"]) {
                                                                        t_op_valide["timestamp"]["preendo"][round_cib][va] = new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds(); //
                                                                        t_op_valide["reception"]["preendo"][round_cib][va] = 0; //
                                                                    } else {
                                                                        t_op_valide["timestamp"]["preendo"][round_cib] = {};
                                                                        t_op_valide["reception"]["preendo"][round_cib] = {};
                                                                        t_op_valide["timestamp"]["preendo"][round_cib][va] = new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds(); //
                                                                        t_op_valide["reception"]["preendo"][round_cib][va] = 0; //

                                                                    }
                                                                }
                                                                else {


                                                                    t_op_valide["timestamp"]["endo"][va] = new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds(); //
                                                                    t_op_valide["reception"]["endo"][va] = new Date(new Date(v["operations"][i]["reception_time"]) - t_recep[round_cib]).getSeconds(); //

                                                                }
                                                            }
                                                        }

                                                    }
                                                }

                                            }
                                        }

                                    }
                                    catch (error) {
                                        console.log(error); // endo manqués
                                    }
                                } catch (error) {

                                    console.log(error);

                                }
                            }




                        });


                    }//fin du if
                    else { // en chantier !! 
                        //console.log("Block round=0")

                        Object.entries(dict_data[va]["endorsements"]).forEach(([k, v]) => {
                            //console.log(v); // array avec delegate et OP
                            //console.log(adress);
                            if (v['delegate'] == adress) { //s'il s'agit du délégué visé
                                console.log("A1");
                                try { //traitement des blocs avec block round > 0 et payload round = 0                                      
                                    //console.log((v["operations"]).length);
                                    if (v["operations"]) {
                                        for (let i = 0; i < (v["operations"]).length; i++) {
                                            console.log(v["operations"][i]);

                                            try {
                                                round_cib = v["operations"][i]["round"];
                                                if ("errors" in v["operations"][i]) { // L'OP n'est pas valide ?
                                                    //console.log(v["operations"][i]["errors"]);
                                                    if ("provided" in v["operations"][i]["errors"][0]) {
                                                        //console.log("provided");
                                                        if (v["operations"][i]["errors"][0]["provided"] == 1 | v["operations"][i]["errors"][0]["provided"] == 0) {
                                                            //console.log("provided=1");
                                                            //L'erreur concerne le bloc


                                                            if (("kind" in v["operations"][i])) { // preendo  if (round_cib != round_bloc) { <= aller chercher round cib

                                                                if (round_cib in t_baker) {

                                                                    if (("reception_time" in v["operations"][i])) {
                                                                        if (v["operations"][i]["reception_time"] != null) {
                                                                            console.log("A2");
                                                                            //ajouter à t_op_error[retard][t_preendo]
                                                                            //t_op_erreur["retard"]["t_pre_approbations"].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());

                                                                            if (v["operations"][i]["errors"][0][round_cib] in t_op_retard["timestamp"]["preendo"]) {
                                                                                t_op_retard["timestamp"]["preendo"][round_cib][va] = new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds(); // 
                                                                                t_op_retard["reception"]["preendo"][round_cib][va] = new Date(new Date(v["operations"][i]["reception_time"]) - t_recep[round_cib]).getSeconds(); // 
                                                                            }
                                                                            else {
                                                                                t_op_retard["timestamp"]["preendo"][round_cib] = {};
                                                                                t_op_retard["reception"]["preendo"][round_cib] = {};

                                                                                t_op_retard["timestamp"]["preendo"][round_cib][va] = new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds(); // 
                                                                                t_op_retard["reception"]["preendo"][round_cib][va] = new Date(new Date(v["operations"][i]["reception_time"]) - t_recep[round_cib]).getSeconds();
                                                                            }

                                                                            //ano_desc[round_cib]["pre_approbations"]["invalide"].push([v["delegate"], v["operations"][i]["errors"][0]["id"]])
                                                                        }
                                                                    }

                                                                }




                                                            }
                                                            else {//endo
                                                                if (round_cib in t_baker) {

                                                                    if (("reception_time" in v["operations"][i])) {
                                                                        if (v["operations"][i]["reception_time"] != null) {


                                                                            if (("included_in_blocks" in v["operations"][i])) {
                                                                                console.log("B2");
                                                                                //t_op_error[retard][t_endo]
                                                                                //t_op_erreur["retard"]["t_approbations"].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                                                //ano_desc[round_cib]["approbations"]["invalide"].push([v["delegate"], v["operations"][i]["errors"][0]["id"]])



                                                                                t_op_retard["timestamp"][va] = new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds(); // 
                                                                                t_op_retard["reception"][va] = new Date(new Date(v["operations"][i]["reception_time"]) - t_recep[round_cib]).getSeconds();



                                                                            }



                                                                        }

                                                                    }



                                                                }
                                                            }
                                                        }

                                                    }

                                                }
                                                else { //L'OP est valide ?
                                                    if (round_cib in t_baker) {
                                                        console.log("c")
                                                        if (("kind" in v["operations"][i])) { // preendo  if (round_cib != round_bloc) { <= aller chercher round cib
                                                            console.log("c'")

                                                            if (("reception_time" in v["operations"][i])) {
                                                                //console.log(v["operations"][i]["reception_time"])



                                                                if (v["operations"][i]["reception_time"] != null) {
                                                                    //ajouter à t_op_valide[round_bloc][t_preendo]
                                                                    //console.log(new Date(v["operations"][i]["reception_time"]));
                                                                    //console.log(t_baker);
                                                                    //t_op_pre_valide_i[round_cib].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                                    try {
                                                                        if (round_cib in t_op_valide["timestamp"]["preendo"]) {
                                                                            t_op_valide["timestamp"]["preendo"][round_cib][va] = new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds(); //
                                                                            t_op_valide["reception"]["preendo"][round_cib][va] = new Date(new Date(v["operations"][i]["reception_time"]) - t_recep[round_cib]).getSeconds(); //
                                                                        } else {
                                                                            console.log("A3");
                                                                            t_op_valide["timestamp"]["preendo"][round_cib] = {};
                                                                            t_op_valide["reception"]["preendo"][round_cib] = {};
                                                                            t_op_valide["timestamp"]["preendo"][round_cib][va] = new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds(); //
                                                                            t_op_valide["reception"]["preendo"][round_cib][va] = new Date(new Date(v["operations"][i]["reception_time"]) - t_recep[round_cib]).getSeconds(); //

                                                                        }
                                                                    } catch (e) { console.log(e) };

                                                                    //ano_desc[round_cib]["pre_approbations"]["valide"].push(v["delegate"]);
                                                                    //console.log("PRE APPRO VALIDE");
                                                                    //console.log(v["operations"][i]);

                                                                }
                                                                else {
                                                                    //console.log("date de récep pas dispo");
                                                                    //console.log(v["operations"][i]);
                                                                    //ano_desc[round_cib]["pre_approbations"]["inconnu"].push([v["delegate"], "pas d'erreur + date de recep null"]);
                                                                    //ano_desc[round_cib]["pre_approbations"]["valide"].push(v["delegate"]);


                                                                    //date de récep pas dispo
                                                                }


                                                            }
                                                        }






                                                        else {//endo
                                                            //console.log(v["operations"][i])
                                                            console.log("B3'");


                                                            if (("reception_time" in v["operations"][i])) {
                                                                console.log("B3''");
                                                                //console.log(v["operations"][i]["reception_time"])
                                                                if ("included_in_blocks" in v["operations"][i]) {
                                                                    console.log("B3'''");
                                                                    if (v["operations"][i]["reception_time"] != null) {
                                                                        console.log("B3''''");


                                                                        if (("included_in_blocks" in v["operations"][i])) {
                                                                            //t_op_valide[round_bloc][t_endo]
                                                                            //t_op_valide_i[round_cib].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                                            console.log("B3");

                                                                            t_op_valide["timestamp"]["endo"][va] = new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds(); //
                                                                            t_op_valide["reception"]["endo"][va] = new Date(new Date(v["operations"][i]["reception_time"]) - t_recep[round_cib]).getSeconds(); //


                                                                            //ano_desc[round_cib]["approbations"]["valide"].push(v["delegate"]);


                                                                        }
                                                                        else {
                                                                            //console.log("Pas d'inclusion au bloc => Approbation oubliée");
                                                                            //ano_desc[round_cib]["approbations"]["oublie"].push(v["delegate"]);

                                                                            //console.log(v["operations"]);
                                                                        }


                                                                    }
                                                                    else {


                                                                        op_oublies.push(k);
                                                                    }


                                                                }
                                                            }

                                                            else {
                                                                if (("included_in_blocks" in v["operations"][i]) && (!("reception_time" in v["operations"][i]))) {
                                                                    op_sequestre.push(k);
                                                                }




                                                            }
                                                        }
                                                    }
                                                }
                                            } catch (e) {
                                                console.log(e)

                                            }
                                        }
                                    }
                                    else {
                                        missed_block.push([va, [-1]]);//ajouter aux manqués 
                                    }
                                    try { // D'après Eugen, les erreurs temporaires sont provoqué par la réception d'un preendorsement avant la récep du block candidat, ils sont ensuite réévalué et considéré valides par le réseau 
                                        //console.log(v);
                                        if ("operations" in v) {
                                            for (let i = 0; i < v["operations"].length; i++) {//
                                                if ((("errors" in v["operations"][i]))) { //dès lors qu'on trouve une erreur, on vérifier qu'il s'agit d'une erreur concernant le block ciblé(va) et son round.
                                                    if (v["operations"][i]["errors"][0]["kind"] == "temporary") {
                                                        var block_cib = (v["operations"][i]["errors"][0]["provided"]).toString();
                                                        var round_cib = v["operations"][i]["round"];
                                                        if (block_cib == va) {
                                                            //console.log(v["operations"]);
                                                            //console.log(round_cib);
                                                            if (round_cib in t_baker) {
                                                                if ("kind" in v["operations"][i]) { // c'est un preendo
                                                                    if (round_cib in t_op_valide["timestamp"]["preendo"]) {
                                                                        t_op_valide["timestamp"]["preendo"][round_cib][va] = new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds(); //
                                                                        t_op_valide["reception"]["preendo"][round_cib][va] = 0; //
                                                                    } else {
                                                                        t_op_valide["timestamp"]["preendo"][round_cib] = {};
                                                                        t_op_valide["reception"]["preendo"][round_cib] = {};
                                                                        t_op_valide["timestamp"]["preendo"][round_cib][va] = new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds(); //
                                                                        t_op_valide["reception"]["preendo"][round_cib][va] = 0; //

                                                                    }
                                                                }
                                                                else {


                                                                    t_op_valide["timestamp"]["endo"][va] = new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds(); //
                                                                    t_op_valide["reception"]["endo"][va] = new Date(new Date(v["operations"][i]["reception_time"]) - t_recep[round_cib]).getSeconds(); //

                                                                }
                                                            }
                                                        }

                                                    }
                                                }

                                            }
                                        }

                                    }
                                    catch (error) {
                                        console.log(error); // endo manqués
                                    }
                                } catch (e) {
                                    console.log(e)
                                }
                            }
                        })
                    }
                    resolve([t_op_valide, t_op_retard, missed_block]);
                });

                get_res.then(data_ => console.log(data_))
            });

            //Transformation de t_op_valide, missed_block en un format adapté à la visualisation : nvo fichier ( return_t_op_valide, return_missed_block)
            for (const [bloc_, value0] of Object.entries(t_op_valide["reception"]["endo"])) {
                return_t_op_valide.push({ type: "endo", bloc: +bloc_, d_reception: value0, d_timestamps: t_op_valide["timestamp"]["endo"][bloc_], cat: "Endorsement" })

            }
            for (const [round_, value0] of Object.entries(t_op_valide["reception"]["preendo"])) {
                for (const [bloc_, value1] of Object.entries(value0)) {

                    return_t_op_valide.push({ type: "preendo", bloc: +bloc_, d_reception: value1, d_timestamps: t_op_valide["timestamp"]["preendo"][round_][bloc_], cat: "Preendorsement round: "+round_ })
                }

            }
            console.log(missed_block);
            for (var elem0 in missed_block) {
                for (var elem1 in missed_block[elem0][1]) {
                    console.log(elem1)
                    return_missed.push({ type: "missed", bloc: +missed_block[elem0][0], round: missed_block[elem0][1][elem1] })
                }

            }

            return ([return_t_op_valide, return_missed])
        }



        try {
            $.get(server_adress, null, function (text) {
                //directories=$(text).find("a").text(); //fonctionne !!! 
                $(text).find("a").each(function () {
                    let s = $(this).text();
                })



                /*
                $('form').keyup(function (e) {

                    //document.getElementById('launch').onclick = function() {

                    beg_ = document.getElementById('selectedLevel_begin').value;
                    end_ = document.getElementById('selectedLevel_end').value;
                    threshold_low = document.getElementById('selectedThreshold_beg').value;
                    threshold_high = document.getElementById('selectedThreshold_end').value;

                    ComputeGamma(beg_, end_, threshold_low, threshold_high);


                    var comment = document.getElementsByClassName("getElementBy");
                    for (var i = 0; i < comment.length; i++) {
                        comment[i].addEventListener("keydown", function () {
                            beg_ = document.getElementById('selectedLevel_begin').value;
                            end_ = document.getElementById('selectedLevel_end').value;
                            threshold_low = document.getElementById('selectedThreshold_beg').value;
                            threshold_high = document.getElementById('selectedThreshold_end').value;
                            ComputeGamma(beg_, end_, threshold_low, threshold_high);
                        })
                    }

                    //};
                });
                */

                $('#submit_').mouseup(function (e) {

                    //document.getElementById('launch').onclick = function() {

                    beg_ = document.getElementById('selectedLevel_begin').value;
                    end_ = document.getElementById('selectedLevel_end').value;
                    adresse = document.getElementById('adress_').value;
                    console.log(adresse);
                    const main_ = new Promise((resolve) => {
                        resolve(Resume_OP_cons_adress(beg_, end_, adresse));

                    })

                    main_.then(res => {
                        console.log(res);
                        chart(res[0]);


                        /*console.log("t_op_valide");
                        console.log(t_op_valide);
                        console.log("t_op_retard");
                        console.log(t_op_retard);
                        console.log("missed_block");
                        console.log(missed_block);
                        console.log("op_sequestre");
                        console.log(op_sequestre);
                        console.log("op_oublies");
                        console.log(op_oublies);*/

                    })


                    /*var comment = document.getElementsByClassName("getElementBy");
                    for (var i = 0; i < comment.length; i++) {
                        comment[i].addEventListener("keydown", function () {
                            beg_ = document.getElementById('selectedLevel_begin').value;
                            end_ = document.getElementById('selectedLevel_end').value;
                            threshold_low = document.getElementById('selectedThreshold_beg').value;
                            threshold_high = document.getElementById('selectedThreshold_end').value;
                            ComputeGamma(beg_, end_, threshold_low, threshold_high);
                        })
                    }*/

                    //};
                });




                /*$('form').keyup(function (e) {
                    beg_ = document.getElementById('selectedLevel_begin').value;
                    end_ = document.getElementById('selectedLevel_end').value;
                    threshold_ = document.getElementById('selectedThreshold').value;
                    ComputeAlpha(beg_, end_, threshold_);
                    });*/
            })
        } catch (e) {
            console.log(e)
        }


        function chart(data) {
            var margin = ({ top: 40, right: 220, bottom: 30, left: 40 }),
                width = 870 - margin.left - margin.right;//1000, // outer width of chart, in pixels
            height = 500 - margin.top - margin.bottom;//400; // outer height of chart, in pixels 
            try {
                try {
                    while (document.getElementById("dataviz").querySelector("svg")) {
                        const elements3 = document.getElementById("dataviz").querySelector("svg");
                        document.getElementById("dataviz").removeChild(elements3);
                    }
                } catch (e) {
                    console.log(e)
                }
                const svg = d3.select("body").select("#dataviz").append("svg")
                    .attr("width", width + margin.left + margin.right)
                    .attr("height", height + margin.top + margin.bottom);

                const svgg = svg.append("g")
                    .attr("transform",
                        "translate(" + margin.left + "," + margin.top + ")");


                // Not much changes here with the original function
                // group makes it a little easier, just pass the data and a function that
                // tells you how to get each key. Instead of returning a nest object it returns
                // a javascript Map. We can still iterate over maps as we'll see in a bit.
                //var sumstat = d3.nest() // nest function allows to group the calculation per level of a factor
                //  .key(function(d) { return d.name;})
                //  .entries(data);

                var sumstat = d3.group(data, d => d.cat);

                // Add X axis --> it is a date format
                var x = d3.scaleLinear()
                    .domain(d3.extent(data, d => d.bloc))
                    .range([0, width]);
                svgg.append("g")
                    .attr("transform", "translate(0," + height + ")")
                    .call(d3.axisBottom(x).ticks(5));

                // Add Y axis
                var y = d3.scaleLinear()
                    .domain(d3.extent(data, d => d.d_timestamps))
                    .range([height, 0]);
                svgg.append("g")
                    .attr("transform", "translate(0,0)")
                    .call(d3.axisLeft(y).tickSizeOuter(0));
                
                // color palette
                var res = Array.from(sumstat.keys()); // list of group names
                var color = d3.scaleOrdinal()
                    .domain(res)
                    .range(['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#ffff33', '#a65628', '#f781bf', '#999999'])

                var legend = d3.legendColor().scale(color);

                svgg.append("g").attr("transform", "translate(" + (width) + ",10)").call(legend);

                // This is where things change a bit. First rather than use the append().enter() pattern we're going
                // to use the new 'join' pattern, it's a bit cleaner. Next all we have to realize is that instead of 
                // getting an array of objects have a `key` and `values` properties, it's going to be a length two 
                // array with the key being the first entry and the rest of the data as the second.
                svgg.selectAll(".line")
                    .data(sumstat)
                    .join("path")
                    .attr('fill', 'none')
                    .attr('stroke-width', 1.5)
                    .attr('stroke', d => color(d[0]))
                    .attr("d", d => {
                        return d3.line()
                            .x(d => x(d.bloc))
                            .y(d => y(d.d_timestamps))
                            (d[1])
                    });
                    
                    svgg.selectAll("circle")
                    .data(data)
                    .enter()
                    .append("circle")
                    .attr("fill", "#000000")
                    .attr("stroke",'none')
                    .attr('stroke-width', 1.5)
                    .attr("cx",function (d) { return x(d.bloc)})
                    .attr("cy",function (d) { return y(d.d_timestamps)})
                    .attr("r", 2);

                svgg.append("text")
                    .attr("x", -margin.left + 40)
                    .attr("y", -5)
                    .attr("fill", "currentColor")
                    .attr("text-anchor", "start")
                    .text("↑ reception delays after candidate block timestamps (seconds)");

                svgg.append("text")
                    .attr("x", width + margin.right)
                    .attr("y", height)
                    .attr("fill", "currentColor")
                    .attr("text-anchor", "end")
                    .text(" # Bloc →");

                svgg.append("text")
                    .attr("x", width + 40)
                    .attr("y", 0)
                    .attr("fill", "currentColor")
                    .attr("text-anchor", "end")
                    .text("Round:");


            } catch (e) { console.log(e) }

        }


    </script>
    <div id="dataviz"></div>