<!doctype html>

<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Temps nécessaire pour recevoir n% des preendorsements autorisés</title>
    <script src=https://cdnjs.cloudflare.com/ajax/libs/mathjs/3.3.0/math.min.js></script>
    <script src="https://cdn.jsdelivr.net/npm/d3@7.4.4/dist/d3.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-legend/2.13.0/d3-legend.js"></script>
</head>

<body>
    <h1> Temps nécessaire pour recevoir n% des preendorsements autorisés</h1>
    <form>
        <div>
            <label for="selectedLevel_begin">First bloc:</label>
            <input name="level_" id="selectedLevel_begin" type="number" value="2412550" />
            <span id='tick_begin'></span>
            <br>
            <label for="selectedLevel_end">Last bloc:</label>
            <input name="level_" id="selectedLevel_end" type="number" value="2412700" />
            <span id='tick_end'></span>
            <br>
            <label for="selectedThreshold">Percentage threshold (n):</label>
            <input name="threshold" id="selectedThreshold" type="number" value="66" />
            <br>
            <input type="button" id="submit_" value="Rechercher ">

        </div>
        <div id="beta"></div>
    </form>
    <script>
        const server_adress = "http://78.193.200.52";
        var directories = {};
        var dict_data = {};
        var dict_data = {};
        var directories = {};
        var t_op_retard = {}; // contient plusieurs dict, chacun associé à un round/type(preendo ou endo)
        var t_op_valide = {}; // t_op_erreur[k]= t_op_erreur_i
        var t_op_pre_retard = {}; // contient plusieurs dict, chacun associé à un round/type(preendo ou endo)
        var t_op_pre_valide = {}; // contient plusieurs dict, chacun associé à un round. Ces dict contiennent 2 listes, qui sont les délais de réception pour les Préendorsement et les endorsmenet invalides 

        var t_baker; // date de préparation supposé dans le fichier qui correspond au nom et date de publication dans le fichier suivant(c'est à ce moment qu'il est visible pour les délégués)
        var t_recep; // date de réception du bloc 

        function range(start, end) {
            var ans = [];
            for (let i = start; i <= end; i++) {
                ans.push(i);
            }
            return ans;
        }

        function onlyUnique(value, index, self) {
            return self.indexOf(value) === index;
        }

        $.get(server_adress, null, function (text) {
            //directories=$(text).find("a").text(); //fonctionne !!! 
            $(text).find("a").each(function () {
                let s = $(this).text();
                //console.log(typeof(s));
                if (s.includes('-') == true) {
                    //console.log(s);
                    var minmax = s.split('-');
                    if (+minmax[0] > 0 && +minmax[1] > 0) { // filtrer les autres fichiers 
                        directories[s] = [+minmax[0], +minmax[1]]
                    }


                }
            })
        })

        function ComputeBeta(beg, end, threshold) {

            var range_bloc = range(beg, end);

            range_bloc.forEach((a) => {


                Object.entries(directories).forEach(([k, v]) => {

                    if ((+a) <= v[1] && (+a) >= v[0]) {
                        try {
                            $.getJSON(server_adress + "/" + k + "/" + a + ".json", null, function (json_data) {
                                //console.log(server_adress + "/" + k + "/" + a + ".json");
                                dict_data[a] = json_data;
                                //console.log(dict_data[a]);

                            })
                        } catch {
                            console.log("bloc: " + a + " est introuvable");
                        }
                    }
                })




            })

            Object.entries(dict_data).forEach(([k, v]) => {


                var t_op_retard_i = {}; // contient plusieurs dict, chacun associé à un round/type(preendo ou endo)
                var t_op_valide_i = {}; // t_op_erreur[k]= t_op_erreur_i
                var t_op_pre_retard_i = {}; // contient plusieurs dict, chacun associé à un round/type(preendo ou endo)
                var t_op_pre_valide_i = {}; // t_op_erreur[k]= t_op_erreur_i

                var va = k;
                var va_1 = (parseInt(k) + 1).toString();//#block+1
                var round_bloc; // round final du bloc
                var t_baker = {}; // date de préparation supposé dans le fichier qui correspond au nom et date de publication dans le fichier suivant(c'est à ce moment qu'il est visible pour les délégués)
                var t_recep; // date de réception du bloc 

                try {
                    let r = dict_data[va]["blocks"].length;
                    if (r == 1) {
                        if ("round" in dict_data[va]["blocks"][0]) {
                            t_baker[dict_data[va]["blocks"][0]["round"]] = new Date(dict_data[va]["blocks"][0]["timestamp"]);//date de baking <= timestamps est la date de baking ! a corriger 
                            //console.log("date supposé de baking: " + t_baker);

                        } else {
                            t_baker[0] = new Date(dict_data[va]["blocks"][0]["timestamp"]);//date de baking <= timestamps est la date de baking ! a corriger 
                            //console.log("date supposé de baking: " + t_baker);
                        }
                    }
                    else {

                        (dict_data[va]["blocks"]).forEach((element) => {
                            if (typeof element["round"] !== "undefined") {
                                t_baker[element["round"]] = new Date(element["timestamp"]);
                            } else {
                                t_baker[0] = new Date(element["timestamp"]);
                            }

                        })

                    }
                    //console.log(t_baker);
                }
                catch (error) {
                    //console.log(error);
                }


                try {
                    round_bloc = + dict_data[va]["blocks"][0]["round"];//Si pas de retour => round0
                    if (isNaN(round_bloc)) {
                        round_bloc = 0;

                    }
                    //console.log("Le nombre final de round du bloc est: " + round_bloc);
                }
                catch {
                    round_bloc = 0;
                }

                for (let i = 0; i <= round_bloc; i++) {

                    t_op_retard_i[i] = []; //Memo: Les retards concernent que les preendos?Faire pour les deux: ils sont soit dans le fichier #bloc( kind: temporary, round>0, "expected_max": round-1) fichiers suivant (pour voir si ça correspond à ce qu'on veut, on peut regarder: si expected est dans erreur, si expected= bloc, si kind= temporary)
                    t_op_valide_i[i] = []; // t_op_valide[i][t_approbations]
                    t_op_pre_retard_i[i] = [];
                    t_op_pre_valide_i[i] = [];//t_op_valide[i][t_pre_approbations]

                }



                if (round_bloc > 0) { // Si les éléments de chaque round sont indiqués dans le fichier 

                    Object.entries(dict_data[va]["endorsements"]).forEach(([k, v]) => {
                        //console.log(v); // array avec delegate et OP

                        try { //traitement des blocs avec block round > 0 et payload round = 0                                      
                            //console.log((v["operations"]).length);
                            if ("operations" in v) {
                                for (let i = 0; i < (v["operations"]).length; i++) {
                                    round_cib = v["operations"][i]["round"];
                                    if ("errors" in v["operations"][i]) { // L'OP n'est pas valide ?
                                        //console.log(v["operations"][i]["errors"]);


                                        if ("expected_max" in v["operations"][i]["errors"][0]&&"provided" in v["operations"][i]["errors"][0]) {

                                            if (("kind" in v["operations"][i])) { // preendo  if (round_cib != round_bloc) { <= aller chercher round cib


                                                if (v["operations"][i]["errors"][0]["kind"] == "temporary") {


                                                    if (round_cib in t_baker) {


                                                        if (("reception_time" in v["operations"][i])) {



                                                            if (v["operations"][i]["reception_time"] != null) {
                                                                console.log("A");

                                                                //ajouter à t_op_error[retard][t_preendo]
                                                                //console.log(t_baker[round_cib]);
                                                                //console.log(v["operations"][i]["reception_time"]);
                                                                //console.log();
                                                                t_op_pre_valide_i[v["operations"][i]["errors"][0]["provided"]].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                                ////ano_desc[round_cib]["pre_approbations"]["invalide"].push([v["delegate"], v["operations"][i]["errors"][0]["id"]])
                                                            }
                                                        }
                                                    }

                                                }



                                            }
                                            else {//endo

                                                if (v["operations"][i]["errors"][0]["kind"] == "temporary") {
                                                    if (round_cib in t_baker) {
                                                        if (("reception_time" in v["operations"][i])) {
                                                            if (v["operations"][i]["reception_time"] != null) {
                                                                //ajouter à t_op_error[retard][t_preendo]
                                                                t_op_valide_i[v["operations"][i]["errors"][0]["provided"]].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                                ////ano_desc[round_cib]["pre_approbations"]["invalide"].push([v["delegate"], v["operations"][i]["errors"][0]["id"]])
                                                            }
                                                        }
                                                    }

                                                }

                                            }
                                        }
                                        else if ("expected" in v["operations"][i]["errors"][0]&&"provided" in v["operations"][i]["errors"][0]) {              //Les erreurs "temporary" sont la conséquence de la réception d'une preendo avant le block candidat par le noeud !
                                            if (v["operations"][i]["errors"][0]["kind"] == "temporary") {
                                                var block_cib = (v["operations"][i]["errors"][0]["provided"]).toString();
                                                var round_cib = v["operations"][i]["round"];
                                                if (block_cib == va) {
                                                    //console.log(v["operations"]);
                                                    console.log("A3");
                                                    if (round_cib in t_baker) {
                                                        if ("kind" in v["operations"][i]) { // c'est un preendo
                                                            t_op_pre_valide_i[0].push(0);
                                                        }
                                                        else {
                                                            t_op_valide_i[0].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                        }
                                                    }
                                                }

                                            }
                                        }
                                        else {
                                            if (("kind" in v["operations"][i])) { // preendo  if (round_cib != round_bloc) { <= aller chercher round cib
                                                if (round_bloc == round_cib) {
                                                    if (round_cib in t_baker) {

                                                        if (("reception_time" in v["operations"][i])) {
                                                            if (v["operations"][i]["reception_time"] != null) {
                                                                //ajouter à t_op_error[retard][t_preendo]
                                                                t_op_erreur_i["retard"]["t_pre_approbations"].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                                //ano_desc[round_cib]["pre_approbations"]["invalide"].push([v["delegate"], v["operations"][i]["errors"][0]["id"]])
                                                            }
                                                        }

                                                    }
                                                }
                                                else {
                                                    //console.log

                                                    if (("reception_time" in v["operations"][i])) {
                                                        if (v["operations"][i]["reception_time"] != null) {
                                                            //ajouter à t_op_erreur[round_cib][t_preendo]
                                                            if (round_cib in t_baker) {
                                                                t_op_erreur_i[round_cib]["t_pre_approbations"].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                                //ano_desc[round_cib]["pre_approbations"]["invalide"].push([v["delegate"], v["operations"][i]["errors"][0]["id"]])
                                                            }
                                                        }


                                                    }

                                                }


                                            }
                                            else {//endo
                                                if (round_cib in t_baker) {
                                                    if (round_bloc == round_cib) {

                                                        if (("reception_time" in v["operations"][i])) {
                                                            if (v["operations"][i]["reception_time"] != null) {


                                                                if (("included_in_blocks" in v["operations"][i])) {
                                                                    //t_op_error[retard][t_endo]
                                                                    t_op_erreur_i["retard"]["t_approbations"].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                                    //ano_desc[round_cib]["approbations"]["invalide"].push([v["delegate"], v["operations"][i]["errors"][0]["id"]])


                                                                }



                                                            }

                                                        }

                                                    }
                                                    else {

                                                        if (("reception_time" in v["operations"][i])) {
                                                            if (v["operations"][i]["reception_time"] != null) {
                                                                //ajouter à t_op_erreur[round_cib][t_endo]
                                                                t_op_erreur_i[round_cib]["t_approbations"].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                                //ano_desc[round_cib]["approbations"]["invalide"].push([v["delegate"], v["operations"][i]["errors"][0]["id"]]);


                                                            }


                                                        }
                                                    }

                                                }
                                            }
                                        }
                                        

                                    }
                                    else { //L'OP est valide ?

                                        if (("kind" in v["operations"][i])) { // preendo  if (round_cib != round_bloc) { <= aller chercher round cib
                                            if (("reception_time" in v["operations"][i]) && ("round" in v["operations"][i])) {
                                                //console.log(v["operations"][i]["reception_time"])
                                                if (round_cib in t_baker) {
                                                    if (v["operations"][i]["reception_time"] != null) {
                                                        //ajouter à t_op_valide[round_bloc][t_preendo]
                                                        t_op_pre_valide_i[round_cib].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                        //console.log("passe");
                                                        ////ano_desc[round_cib]["pre_approbations"]["valide"].push(v["delegate"]);
                                                        //console.log("PRE APPRO VALIDE");
                                                        //console.log(v["operations"][i]);

                                                    }
                                                }
                                            }
                                        }
                                        else {//endo

                                            if (("reception_time" in v["operations"][i]) && ("round" in v["operations"][i])) {
                                                //console.log(v["operations"][i]["reception_time"])
                                                if (round_cib in t_baker) {
                                                    if (v["operations"][i]["reception_time"] != null) {
                                                        //ajouter à t_op_valide[round_bloc][t_preendo]
                                                        t_op_valide_i[round_cib].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                        //console.log("passe");
                                                        ////ano_desc[round_cib]["pre_approbations"]["valide"].push(v["delegate"]);
                                                        //console.log("PRE APPRO VALIDE");
                                                        //console.log(v["operations"][i]);

                                                    }
                                                }
                                            }

                                        }
                                    }
                                }
                            }
                        } catch (error) {

                            console.log(error);

                        }

                        /*console.log("t_op_pre_retard_i");
                    console.log(t_op_pre_retard_i);
                    console.log("t_op_valide_i");
                    console.log(t_op_valide_i);
                    console.log("t_op_retard_i");
                    console.log(t_op_retard_i);
                    console.log("t_op_pre_valide_i");
                    console.log(t_op_pre_valide_i);*/

                        t_op_pre_retard[va] = t_op_pre_retard_i;
                        t_op_pre_valide[va] = t_op_pre_valide_i;
                        t_op_retard[va] = t_op_retard_i;
                        t_op_valide[va] = t_op_valide_i;



                    });



                    /*console.log("t_op_pre_retard_i");
                    console.log(t_op_pre_retard_i);
                    console.log("t_op_valide_i");
                    console.log(t_op_valide_i);
                    console.log("t_op_retard_i");
                    console.log(t_op_retard_i);
                    console.log("t_op_pre_valide_i");
                    console.log(t_op_pre_valide_i);*/

                    t_op_pre_retard[va] = t_op_pre_retard_i;
                    t_op_pre_valide[va] = t_op_pre_valide_i;
                    t_op_retard[va] = t_op_retard_i;
                    t_op_valide[va] = t_op_valide_i;


                }//fin du if

                else { // en chantier !! 
                    //console.log("Block round=0")

                    Object.entries(dict_data[va]["endorsements"]).forEach(([k, v]) => {
                        //console.log(v); // array avec delegate et OP

                        try { //traitement des blocs avec block round > 0 et payload round = 0                                      
                            //console.log((v["operations"]).length);
                            for (let i = 0; i < (v["operations"]).length; i++) {
                                round_cib = v["operations"][i]["round"];
                                if ("errors" in v["operations"][i]) { // L'OP n'est pas valide ?
                                    //console.log(v["operations"][i]["errors"]);
                                    
                                        //console.log("provided");
                                        if ("provided" in v["operations"][i]["errors"][0] && "expected_max" in v["operations"][i]["errors"][0]) {
                                            //console.log("provided=1");
                                            //L'erreur concerne le bloc

                                            if (("kind" in v["operations"][i])) { // preendo  if (round_cib != round_bloc) { <= aller chercher round cib
                                                if (v["operations"][i]["errors"][0]["provided"] in t_baker) {

                                                    if (("reception_time" in v["operations"][i])) {
                                                        if (v["operations"][i]["reception_time"] != null) {
                                                            //ajouter à t_op_error[retard][t_preendo]
                                                            t_op_pre_valide_i[v["operations"][i]["errors"][0]["provided"]]["t_pre_approbations"].push(0);
                                                            //ano_desc[round_cib]["pre_approbations"]["invalide"].push([v["delegate"], v["operations"][i]["errors"][0]["id"]])
                                                        }
                                                    }

                                                }
                                            }
                                            else {//endo
                                                if (v["operations"][i]["errors"][0]["provided"] in t_baker) {
                                                    if (("reception_time" in v["operations"][i])) {
                                                        if (v["operations"][i]["reception_time"] != null) {


                                                            if (("included_in_blocks" in v["operations"][i])) {
                                                                //t_op_error[retard][t_endo]
                                                                t_op_valide_i[v["operations"][i]["errors"][0]["provided"]].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                                //ano_desc[round_cib]["approbations"]["invalide"].push([v["delegate"], v["operations"][i]["errors"][0]["id"]])


                                                            }



                                                        }

                                                    }



                                                }
                                            }


                                        }
                                        else if ("provided" in v["operations"][i]["errors"][0] && "expected" in v["operations"][i]["errors"][0]) {

                                            if (("kind" in v["operations"][i])) { // preendo  if (round_cib != round_bloc) { <= aller chercher round cib


                                                if (("reception_time" in v["operations"][i])) {
                                                    if (v["operations"][i]["reception_time"] != null) {
                                                        //ajouter à t_op_error[retard][t_preendo]
                                                        t_op_pre_valide_i[0]["t_pre_approbations"].push(0);
                                                        //ano_desc[round_cib]["pre_approbations"]["invalide"].push([v["delegate"], v["operations"][i]["errors"][0]["id"]])
                                                    }
                                                }


                                            }
                                            else {//endo

                                                if (("reception_time" in v["operations"][i])) {
                                                    if (v["operations"][i]["reception_time"] != null) {


                                                        if (("included_in_blocks" in v["operations"][i])) {
                                                            //t_op_error[retard][t_endo]
                                                            t_op_valide_i[0].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                            //ano_desc[round_cib]["approbations"]["invalide"].push([v["delegate"], v["operations"][i]["errors"][0]["id"]])


                                                        }



                                                    }

                                                }




                                            }

                                        }
                                        else {
                                            if (("kind" in v["operations"][i])) { // preendo  if (round_cib != round_bloc) { <= aller chercher round cib
                                                if (round_bloc == round_cib) {
                                                    if (round_cib in t_baker) {

                                                        if (("reception_time" in v["operations"][i])) {
                                                            if (v["operations"][i]["reception_time"] != null) {
                                                                //ajouter à t_op_error[retard][t_preendo]
                                                                t_op_erreur_i["retard"]["t_pre_approbations"].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                                //ano_desc[round_cib]["pre_approbations"]["invalide"].push([v["delegate"], v["operations"][i]["errors"][0]["id"]])
                                                            }
                                                        }

                                                    }
                                                }
                                                else {
                                                    //console.log

                                                    if (("reception_time" in v["operations"][i])) {
                                                        if (v["operations"][i]["reception_time"] != null) {
                                                            //ajouter à t_op_erreur[round_cib][t_preendo]
                                                            if (round_cib in t_baker) {
                                                                t_op_erreur_i[round_cib]["t_pre_approbations"].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                                //ano_desc[round_cib]["pre_approbations"]["invalide"].push([v["delegate"], v["operations"][i]["errors"][0]["id"]])
                                                            }
                                                        }


                                                    }

                                                }


                                            }
                                            else {//endo
                                                if (round_cib in t_baker) {
                                                    if (round_bloc == round_cib) {

                                                        if (("reception_time" in v["operations"][i])) {
                                                            if (v["operations"][i]["reception_time"] != null) {


                                                                if (("included_in_blocks" in v["operations"][i])) {
                                                                    //t_op_error[retard][t_endo]
                                                                    t_op_erreur_i["retard"]["t_approbations"].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                                    //ano_desc[round_cib]["approbations"]["invalide"].push([v["delegate"], v["operations"][i]["errors"][0]["id"]])


                                                                }



                                                            }

                                                        }

                                                    }
                                                    else {

                                                        if (("reception_time" in v["operations"][i])) {
                                                            if (v["operations"][i]["reception_time"] != null) {
                                                                //ajouter à t_op_erreur[round_cib][t_endo]
                                                                t_op_erreur_i[round_cib]["t_approbations"].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                                //ano_desc[round_cib]["approbations"]["invalide"].push([v["delegate"], v["operations"][i]["errors"][0]["id"]]);


                                                            }


                                                        }
                                                    }

                                                }
                                            }
                                        }

                                    

                                }
                                else { //L'OP est valide ?
                                    if (round_cib in t_baker) {
                                        if (("kind" in v["operations"][i])) { // preendo  if (round_cib != round_bloc) { <= aller chercher round cib
                                            if (round_bloc == round_cib) {

                                                if (("reception_time" in v["operations"][i])) {
                                                    //console.log(v["operations"][i]["reception_time"])
                                                    if (v["operations"][i]["reception_time"] != null) {
                                                        //ajouter à t_op_valide[round_bloc][t_preendo]
                                                        //console.log(new Date(v["operations"][i]["reception_time"]));
                                                        //console.log(t_baker);
                                                        t_op_pre_valide_i[round_cib].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                        //ano_desc[round_cib]["pre_approbations"]["valide"].push(v["delegate"]);
                                                        //console.log("PRE APPRO VALIDE");
                                                        //console.log(v["operations"][i]);

                                                    }
                                                    else {
                                                        //console.log("date de récep pas dispo");
                                                        //console.log(v["operations"][i]);
                                                        //ano_desc[round_cib]["pre_approbations"]["inconnu"].push([v["delegate"], "pas d'erreur + date de recep null"]);
                                                        //ano_desc[round_cib]["pre_approbations"]["valide"].push(v["delegate"]);


                                                        //date de récep pas dispo
                                                    }

                                                } else {
                                                    // jamais reçu => Manquées
                                                    //console.log("jamais reçu => Manquées");
                                                    //console.log(v["operations"][i]);
                                                    //ano_desc[round_cib]["pre_approbations"]["sequestre"].push(v["delegate"]);

                                                }

                                            }
                                            else {

                                                if (("reception_time" in v["operations"][i])) {
                                                    //console.log(v["operations"][i]["reception_time"])
                                                    if (v["operations"][i]["reception_time"] != null) {
                                                        //ajouter à t_op_valide[round_cib][t_preendo]
                                                        t_op_pre_valide_i[round_cib].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                        //ano_desc[round_cib]["pre_approbations"]["valide"].push(v["delegate"]);
                                                    }
                                                    else {
                                                        //date de récep pas dispo et valide
                                                        //ano_desc[round_cib]["pre_approbations"]["inconnu"].push([v["delegate"], "pas d'erreur + date de recep null"]);
                                                        //ano_desc[round_cib]["pre_approbations"]["valide"].push(v["delegate"]);

                                                    }

                                                } else {
                                                    // jamais reçu => Manquées également 
                                                    //ano_desc[round_cib]["pre_approbations"]["sequestre"].push(v["delegate"]);
                                                }

                                            }


                                        }
                                        else {//endo
                                            //console.log(v["operations"][i])

                                            if (round_bloc == round_cib) {

                                                if (("reception_time" in v["operations"][i])) {
                                                    //console.log(v["operations"][i]["reception_time"])
                                                    if (v["operations"][i]["reception_time"] != null) {


                                                        if (("included_in_blocks" in v["operations"][i])) {
                                                            //t_op_valide[round_bloc][t_endo]
                                                            t_op_valide_i[round_cib].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                            //ano_desc[round_cib]["approbations"]["valide"].push(v["delegate"]);


                                                        }
                                                        else {
                                                            //console.log("Pas d'inclusion au bloc => Approbation oubliée");
                                                            //ano_desc[round_cib]["approbations"]["oublie"].push(v["delegate"]);

                                                            //console.log(v["operations"]);
                                                        }


                                                    }
                                                    else {
                                                        //date de récep pas dispo
                                                        //ano_desc[round_cib]["approbations"]["inconnu"].push([v["delegate"], "pas d'erreur + date de recep null"]);
                                                        //ano_desc[round_cib]["approbations"]["valide"].push(v["delegate"]);
                                                    }
                                                }

                                                else {
                                                    // jamais reçu => Manquées
                                                    //ano_desc[round_cib]["approbations"]["sequestre"].push(v["delegate"]);
                                                }

                                            }
                                            else {

                                                if (("reception_time" in v["operations"][i])) {
                                                    //console.log(v["operations"][i]["reception_time"])
                                                    if (v["operations"][i]["reception_time"] != null) {
                                                        //ajouter à t_op_valide[round_cib][t_endo]
                                                        t_op_pre_valide_i[round_cib].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                        //ano_desc[round_cib]["approbations"]["valide"].push(v["delegate"]);

                                                    }
                                                    else {
                                                        //date de récep pas dispo
                                                        //ano_desc[round_cib]["approbations"]["inconnu"].push([v["delegate"], "pas d'erreur + date de recep null"]);
                                                        //ano_desc[round_cib]["approbations"]["valide"].push(v["delegate"]);

                                                    }

                                                } else {
                                                    console.log("jamais reçu => Manquées également");
                                                    //ano_desc[round_cib]["approbations"]["sequestre"].push(v["delegate"]);

                                                }

                                            }


                                        }
                                    }
                                }
                            }


                        } catch (error) {
                            //ano_desc["0"]["approbations"]["manque"].push(v["delegate"]);
                            //console.log("ce sont des manqués");
                            //console.log(k);
                            //console.log(v);

                        }

                    });




                    t_op_pre_retard[va] = t_op_pre_retard_i;
                    t_op_pre_valide[va] = t_op_pre_valide_i;
                    t_op_retard[va] = t_op_retard_i;
                    t_op_valide[va] = t_op_valide_i;



                }














                // t_op_erreur[k]= t_op_erreur_i
                //// t_op_valide[k]= t_op_valide_i
            });

            try {
                let l_ = threshold / 100;

                const qd_ = 250; // nombre de slots pour ce block; endorsing power ? 
                var t_min_ = {}; // dict pour relier le temps min pour qu'un bloc soit valide à son #bloc
                var d3_t_min_ = [];
                new Promise((resolve, reject) => { //Qd besoin de sync : https://www.freecodecamp.org/news/synchronous-vs-asynchronous-in-javascript/
                    Object.entries(t_op_pre_valide).forEach(([bloc, v_bloc]) => {
                        try {
                            var last_round_ = Object.keys(v_bloc).map(Number);
                            console.log(last_round_);
                            if (last_round_.length != 1) {
                                last_round_.sort(function (a, b) {
                                    return a - b
                                });
                            }
                            var block_fin = v_bloc[last_round_[last_round_.length - 1]]; // On se base pour ce graphe sur les rounds valides... généralement le dernier du bloc
                            console.log(block_fin);
                            block_fin.sort(function (a, b) {
                                return a - b;
                            });// trier le vecteur de délais de récep, par ordre croissant
                            seuil_validation = block_fin[Math.ceil(qd_ * l_)]; // Date à laquelle on a le nombre min de preendo pour que le round soit valide 
                            t_min_[bloc] = seuil_validation;
                            if (isNaN(seuil_validation) == false) {
                                d3_t_min_.push({ bloc: (+bloc), t: (+seuil_validation) });
                            }
                        }
                        catch (e) {
                            console.log(bloc, ": ", e)
                        }
                    });
                    resolve(d3_t_min_)
                }).then(resolve => {
                    chart_beta(resolve);
                    console.log("Beta: ", resolve);
                })//)
            } catch (e) { console.log(e) }




        }

        try {
            $.get(server_adress, null, function (text) {
                //directories=$(text).find("a").text(); //fonctionne !!! 
                $(text).find("a").each(function () {
                    let s = $(this).text();
                })
                /*$('form').keyup(function (e) {

                    //document.getElementById('launch').onclick = function() {

                    beg_ = document.getElementById('selectedLevel_begin').value;
                    end_ = document.getElementById('selectedLevel_end').value;
                    threshold_ = document.getElementById('selectedThreshold').value;
                    ComputeBeta(beg_, end_, threshold_);


                    var comment = document.getElementsByClassName("getElementBy");
                    for (var i = 0; i < comment.length; i++) {
                        comment[i].addEventListener("keydown", function () {
                            beg_ = document.getElementById('selectedLevel_begin').value;
                            end_ = document.getElementById('selectedLevel_end').value;
                            threshold_ = document.getElementById('selectedThreshold').value;
                            ComputeBeta(beg_, end_, threshold_);
                        })
                    }

                    //};
                });*/

                $('#submit_').mouseup(function (e) {

                    beg_ = document.getElementById('selectedLevel_begin').value;
                    end_ = document.getElementById('selectedLevel_end').value;
                    threshold_ = document.getElementById('selectedThreshold').value;
                    ComputeBeta(beg_, end_, threshold_);

                    var comment = document.getElementsByClassName("getElementBy");
                    for (var i = 0; i < comment.length; i++) {
                        comment[i].addEventListener("keydown", function () {
                            beg_ = document.getElementById('selectedLevel_begin').value;
                            end_ = document.getElementById('selectedLevel_end').value;
                            threshold_ = document.getElementById('selectedThreshold').value;
                            ComputeBeta(beg_, end_, threshold_);
                        })
                    }




                });

                /*$('form').keyup(function (e) {
                    beg_ = document.getElementById('selectedLevel_begin').value;
                    end_ = document.getElementById('selectedLevel_end').value;
                    threshold_ = document.getElementById('selectedThreshold').value;
                    ComputeAlpha(beg_, end_, threshold_);
                    });*/
            })
        } catch (e) {
            console.log(e)
        }

        function chart_beta(data) {
            var margin = ({ top: 40, right: 60, bottom: 30, left: 40 }),
                width = 800 - margin.left - margin.right;//1000, // outer width of chart, in pixels
            height = 400 - margin.top - margin.bottom;//400; // outer height of chart, in pixels 
            try {
                try {
                    while (document.getElementById("beta").querySelector("svg")) {
                        const elements3 = document.getElementById("beta").querySelector("svg");
                        document.getElementById("beta").removeChild(elements3);
                    }
                } catch (e) {
                    console.log(e)
                }
                var svg = d3.select("body").select("#beta").append("svg").attr("width", width + margin.left + margin.right)
                    .attr("height", height + margin.top + margin.bottom)
                    .append("g")
                    .attr("transform",
                        "translate(" + margin.left + "," + margin.top + ")");

                var x = d3.scaleLinear()
                    .domain(d3.extent(data, function (d) { return d.bloc; }))
                    .range([0, width]);
                svg.append("g")
                    .attr("transform", "translate(0," + (height + 5) + ")")
                    .call(d3.axisBottom(x).ticks(5).tickSizeOuter(0)); //(0," + (height + 5) + ")")


                var y = d3.scaleLinear()
                    .domain(d3.extent(data, function (d) { return d.t; }))
                    .range([height, 0]);
                svg.append("g")
                    .attr("transform", "translate(-5,0)")
                    .call(d3.axisLeft(y).tickSizeOuter(0));

                // Add the area
                /*svg.append("path")
                    .datum(data)
                    .attr("fill", "#69b3a2")
                    .attr("fill-opacity", .3)
                    .attr("stroke", "none")
                    .attr("d", d3.area()
                        .x(function (d) { return x(d.bloc) })
                        .y0(height)
                        .y1(function (d) { return y(d.t) })
                    )*/

                // Add the line
                svg.append("path")
                    .datum(data)
                    .attr("fill", "none")
                    .attr("stroke", "#69b3a2")
                    .attr("stroke-width", 2)
                    .attr("d", d3.line()
                        .x(function (d) { return x(d.bloc) })
                        .y(function (d) { return y(d.t) })
                    )


                // Add the line
                svg.selectAll("myCircles")
                    .data(data)
                    .enter()
                    .append("circle")
                    .attr("fill", "#3288BD")
                    .attr("stroke", "none")
                    .attr("cx", function (d) { return x(d.bloc) })
                    .attr("cy", function (d) { return y(d.t) })
                    .attr("r", 2);

                svg.append("text")
                    .attr("x", -margin.left + 40)
                    .attr("y", 0)
                    .attr("fill", "currentColor")
                    .attr("text-anchor", "start")
                    .text("↑ Temps minimun(s)");

                svg.append("text")
                    .attr("x", width + margin.right)
                    .attr("y", height)
                    .attr("fill", "currentColor")
                    .attr("text-anchor", "end")
                    .text(" # bloc →");




            } catch (e) { console.log(e) }

        }
    </script>

</body>