<!doctype html>

<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Preendorsement inclusion based on threshold time</title>
    <script src=https://cdnjs.cloudflare.com/ajax/libs/mathjs/3.3.0/math.min.js></script>
    <script src="https://cdn.jsdelivr.net/npm/d3@7.4.4/dist/d3.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-legend/2.13.0/d3-legend.js"></script>
</head>

<body>
    <h1> Proportion of preendorsement received before threshold time</h1>
    <form>
        <div>
            <label for="selectedLevel_begin">First Bloc:</label>
            <input name="level_" id="selectedLevel_begin" type="number" value="2412550" />
            <span id='tick_begin'></span>
            <br>
            <label for="selectedLevel_end">Last bloc:</label>
            <input name="level_" id="selectedLevel_end" type="number" value="2412700" />
            <span id='tick_end'></span>
            <br>
            <label for="selectedThreshold">Temporal threshold:</label>
            <input name="threshold" id="selectedThreshold" type="number" value="15" />
            <br>
            <input type="button" id="submit_" value="Rechercher ">

        </div>
    </form>
    <script>
        const server_adress = "http://78.193.200.52";
        var directories = {};
        var dict_data = {};
        var dict_data = {};
        var directories = {};
        var t_op_retard = {}; // contient plusieurs dict, chacun associé à un round/type(preendo ou endo)
        var t_op_valide = {}; // t_op_erreur[k]= t_op_erreur_i
        var t_op_pre_retard = {}; // contient plusieurs dict, chacun associé à un round/type(preendo ou endo)
        var t_op_pre_valide = {}; // contient plusieurs dict, chacun associé à un round. Ces dict contiennent 2 listes, qui sont les délais de réception pour les Préendorsement et les endorsmenet invalides 

        var t_baker; // date de préparation supposé dans le fichier qui correspond au nom et date de publication dans le fichier suivant(c'est à ce moment qu'il est visible pour les délégués)
        var t_recep; // date de réception du bloc 

        function range(start, end) {
            var ans = [];
            for (let i = start; i <= end; i++) {
                ans.push(i);
            }
            return ans;
        }

        function onlyUnique(value, index, self) {
            return self.indexOf(value) === index;
        }

        $.get(server_adress, null, function (text) {
            //directories=$(text).find("a").text(); //fonctionne !!! 
            $(text).find("a").each(function () {
                let s = $(this).text();
                //console.log(typeof(s));
                if (s.includes('-') == true) {
                    //console.log(s);
                    var minmax = s.split('-');
                    if (+minmax[0] > 0 && +minmax[1] > 0) { // filtrer les autres fichiers 
                        directories[s] = [+minmax[0], +minmax[1]]
                    }


                }
            })
        })

        function ComputeAlpha(beg, end, threshold) {

            var range_bloc = range(beg, end);

            range_bloc.forEach((a) => {


                Object.entries(directories).forEach(([k, v]) => {

                    if ((+a) <= v[1] && (+a) >= v[0]) {
                        try {
                            $.getJSON(server_adress + "/" + k + "/" + a + ".json", null, function (json_data) {
                                //console.log(server_adress + "/" + k + "/" + a + ".json");
                                dict_data[a] = json_data;
                                //console.log(dict_data[a]);

                            })
                        } catch {
                            console.log("bloc: " + a + " est introuvable");
                        }
                    }
                })




            })

            Object.entries(dict_data).forEach(([k, v]) => {


                var t_op_retard_i = {}; // contient plusieurs dict, chacun associé à un round/type(preendo ou endo)
                var t_op_valide_i = {}; // t_op_erreur[k]= t_op_erreur_i
                var t_op_pre_retard_i = {}; // contient plusieurs dict, chacun associé à un round/type(preendo ou endo)
                var t_op_pre_valide_i = {}; // t_op_erreur[k]= t_op_erreur_i

                var va = k;
                var va_1 = (parseInt(k) + 1).toString();//#block+1
                var round_bloc; // round final du bloc
                var t_baker = {}; // date de préparation supposé dans le fichier qui correspond au nom et date de publication dans le fichier suivant(c'est à ce moment qu'il est visible pour les délégués)
                var t_recep; // date de réception du bloc 

                try {
                    let r = dict_data[va]["blocks"].length;
                    if (r == 1) {
                        if ("round" in dict_data[va]["blocks"][0]) {
                            t_baker[dict_data[va]["blocks"][0]["round"]] = new Date(dict_data[va]["blocks"][0]["timestamp"]);//date de baking <= timestamps est la date de baking ! a corriger 
                            //console.log("date supposé de baking: " + t_baker);

                        } else {
                            t_baker[0] = new Date(dict_data[va]["blocks"][0]["timestamp"]);//date de baking <= timestamps est la date de baking ! a corriger 
                            //console.log("date supposé de baking: " + t_baker);
                        }
                    }
                    else {

                        (dict_data[va]["blocks"]).forEach((element) => {
                            if (typeof element["round"] !== "undefined") {
                                t_baker[element["round"]] = new Date(element["timestamp"]);
                            } else {
                                t_baker[0] = new Date(element["timestamp"]);
                            }

                        })

                    }
                    //console.log(t_baker);
                }
                catch (error) {
                    //console.log(error);
                }


                try {
                    round_bloc = + dict_data[va]["blocks"][0]["round"];//Si pas de retour => round0
                    if (isNaN(round_bloc)) {
                        round_bloc = 0;

                    }
                    //console.log("Le nombre final de round du bloc est: " + round_bloc);
                }
                catch {
                    round_bloc = 0;
                }

                for (let i = 0; i <= round_bloc; i++) {

                    t_op_retard_i[i] = []; //Memo: Les retards concernent que les preendos?Faire pour les deux: ils sont soit dans le fichier #bloc( kind: temporary, round>0, "expected_max": round-1) fichiers suivant (pour voir si ça correspond à ce qu'on veut, on peut regarder: si expected est dans erreur, si expected= bloc, si kind= temporary)
                    t_op_valide_i[i] = []; // t_op_valide[i][t_approbations]
                    t_op_pre_retard_i[i] = [];
                    t_op_pre_valide_i[i] = [];//t_op_valide[i][t_pre_approbations]

                }



                if (round_bloc > 0) { // Si les éléments de chaque round sont indiqués dans le fichier 

                    Object.entries(dict_data[va]["endorsements"]).forEach(([k, v]) => {
                        //console.log(v); // array avec delegate et OP

                        try { //traitement des blocs avec block round > 0 et payload round = 0                                      
                            //console.log((v["operations"]).length);
                            if ("operations" in v) {
                                for (let i = 0; i < (v["operations"]).length; i++) {
                                    round_cib = v["operations"][i]["round"];
                                    if ("errors" in v["operations"][i]) { // L'OP n'est pas valide ?
                                        //console.log(v["operations"][i]["errors"]);


                                        if ("expected_max" in v["operations"][i]["errors"][0]) {

                                            if (("kind" in v["operations"][i])) { // preendo  if (round_cib != round_bloc) { <= aller chercher round cib


                                                if (v["operations"][i]["errors"][0]["kind"] == "temporary") {


                                                    if (round_cib in t_baker) {


                                                        if (("reception_time" in v["operations"][i])) {



                                                            if (v["operations"][i]["reception_time"] != null) {
                                                                console.log("A");

                                                                //ajouter à t_op_error[retard][t_preendo]
                                                                //console.log(t_baker[round_cib]);
                                                                //console.log(v["operations"][i]["reception_time"]);
                                                                //console.log();
                                                                t_op_pre_retard_i[v["operations"][i]["errors"][0]["expected_max"]].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                                ////ano_desc[round_cib]["pre_approbations"]["invalide"].push([v["delegate"], v["operations"][i]["errors"][0]["id"]])
                                                            }
                                                        }
                                                    }

                                                }



                                            }
                                            else {//endo

                                                if (v["operations"][i]["errors"][0]["kind"] == "temporary") {
                                                    if (round_cib in t_baker) {
                                                        if (("reception_time" in v["operations"][i])) {
                                                            if (v["operations"][i]["reception_time"] != null) {
                                                                //ajouter à t_op_error[retard][t_preendo]
                                                                t_op_retard_i[v["operations"][i]["errors"][0]["expected_max"]].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                                ////ano_desc[round_cib]["pre_approbations"]["invalide"].push([v["delegate"], v["operations"][i]["errors"][0]["id"]])
                                                            }
                                                        }
                                                    }

                                                }

                                            }
                                        }

                                    }
                                    else { //L'OP est valide ?

                                        if (("kind" in v["operations"][i])) { // preendo  if (round_cib != round_bloc) { <= aller chercher round cib
                                            if (("reception_time" in v["operations"][i]) && ("round" in v["operations"][i])) {
                                                //console.log(v["operations"][i]["reception_time"])
                                                if (round_cib in t_baker) {
                                                    if (v["operations"][i]["reception_time"] != null) {
                                                        //ajouter à t_op_valide[round_bloc][t_preendo]
                                                        t_op_pre_valide_i[round_cib].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                        //console.log("passe");
                                                        ////ano_desc[round_cib]["pre_approbations"]["valide"].push(v["delegate"]);
                                                        //console.log("PRE APPRO VALIDE");
                                                        //console.log(v["operations"][i]);

                                                    }
                                                }
                                            }
                                        }
                                        else {//endo

                                            if (("reception_time" in v["operations"][i]) && ("round" in v["operations"][i])) {
                                                //console.log(v["operations"][i]["reception_time"])
                                                if (round_cib in t_baker) {
                                                    if (v["operations"][i]["reception_time"] != null) {
                                                        //ajouter à t_op_valide[round_bloc][t_preendo]
                                                        t_op_valide_i[round_cib].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                        //console.log("passe");
                                                        ////ano_desc[round_cib]["pre_approbations"]["valide"].push(v["delegate"]);
                                                        //console.log("PRE APPRO VALIDE");
                                                        //console.log(v["operations"][i]);

                                                    }
                                                }
                                            }

                                        }
                                    }
                                }
                            }
                        } catch (error) {

                            console.log(error);

                        }

                        /*console.log("t_op_pre_retard_i");
                    console.log(t_op_pre_retard_i);
                    console.log("t_op_valide_i");
                    console.log(t_op_valide_i);
                    console.log("t_op_retard_i");
                    console.log(t_op_retard_i);
                    console.log("t_op_pre_valide_i");
                    console.log(t_op_pre_valide_i);*/

                        t_op_pre_retard[va] = t_op_pre_retard_i;
                        t_op_pre_valide[va] = t_op_pre_valide_i;
                        t_op_retard[va] = t_op_retard_i;
                        t_op_valide[va] = t_op_valide_i;



                    });

                    //On commence la recherche des retards dans le bloc suivant ici, (pour voir si ça correspond à ce qu'on veut, on peut regarder: si expected est dans erreur, si expected= bloc, si kind= temporary)

                    Object.entries(directories).forEach(([k, v]) => {

                        if ((+va_1) <= v[1] && (+va_1) >= v[0]) {
                            //console.log("The key: ", k);
                            //console.log("min: ", v[0]);
                            //console.log("max: ", v[1]);
                            $.getJSON(server_adress + "/" + k + "/" + va_1 + ".json", null, function (json_data) { //traitement du reste
                                var item_i = [];
                                dict_data[va_1] = json_data
                                //console.log(t_baker);
                                try { // traitement de l'info du fichier correspondant au bloc
                                    //Info relatives aux (pre)approbations valides du bloc va
                                    Object.entries(dict_data[va_1]["endorsements"]).forEach(([k, v]) => {
                                        try {
                                            //console.log(v);
                                            if ("operations" in v) {
                                                for (let i = 0; i < v["operations"].length; i++) {//
                                                    if ((("errors" in v["operations"][i]))) { //dès lors qu'on trouve une erreur, on vérifier qu'il s'agit d'une erreur concernant le block ciblé(va) et son round.
                                                        if (v["operations"][i]["errors"][0]["kind"] == "temporary") {
                                                            var block_cib = (v["operations"][i]["errors"][0]["expected"]).toString();
                                                            var round_cib = v["operations"][i]["round"];
                                                            if (block_cib == va) {
                                                                //console.log(v["operations"]);
                                                                //console.log(round_cib);
                                                                if (round_cib in t_baker) {
                                                                    if ("kind" in v["operations"][i]) { // c'est un preendo
                                                                        t_op_pre_retard_i[round_cib].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                                    }
                                                                    else {
                                                                        console.log(v["operations"][i]["errors"][0]["expected_max"]);
                                                                        t_op_retard_i[round_cib].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                                    }
                                                                }
                                                            }

                                                        }
                                                    }

                                                }
                                            }

                                        }
                                        catch (error) {
                                            console.log(error); // endo manqués
                                        }
                                    });

                                }
                                catch (error) {
                                    console.log(error);
                                }
                            });
                        }
                    });

                    /*console.log("t_op_pre_retard_i");
                    console.log(t_op_pre_retard_i);
                    console.log("t_op_valide_i");
                    console.log(t_op_valide_i);
                    console.log("t_op_retard_i");
                    console.log(t_op_retard_i);
                    console.log("t_op_pre_valide_i");
                    console.log(t_op_pre_valide_i);*/

                    t_op_pre_retard[va] = t_op_pre_retard_i;
                    t_op_pre_valide[va] = t_op_pre_valide_i;
                    t_op_retard[va] = t_op_retard_i;
                    t_op_valide[va] = t_op_valide_i;


                }//fin du if

                else { // en chantier !! 
                    //console.log("Block round=0")

                    Object.entries(dict_data[va]["endorsements"]).forEach(([k, v]) => {
                        //console.log(v); // array avec delegate et OP

                        try { //traitement des blocs avec block round > 0 et payload round = 0                                      
                            //console.log((v["operations"]).length);
                            for (let i = 0; i < (v["operations"]).length; i++) {
                                round_cib = v["operations"][i]["round"];
                                if ("errors" in v["operations"][i]) { // L'OP n'est pas valide ?
                                    //console.log(v["operations"][i]["errors"]);
                                    if ("provided" in v["operations"][i]["errors"][0]) {
                                        //console.log("provided");
                                        if (v["operations"][i]["errors"][0]["provided"] == 1 | v["operations"][i]["errors"][0]["provided"] == 0) {
                                            //console.log("provided=1");
                                            //L'erreur concerne le bloc


                                            if (("kind" in v["operations"][i])) { // preendo  if (round_cib != round_bloc) { <= aller chercher round cib
                                                if (round_bloc == round_cib) {
                                                    if (round_cib in t_baker) {

                                                        if (("reception_time" in v["operations"][i])) {
                                                            if (v["operations"][i]["reception_time"] != null) {
                                                                //ajouter à t_op_error[retard][t_preendo]
                                                                t_op_erreur["retard"]["t_pre_approbations"].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                                //ano_desc[round_cib]["pre_approbations"]["invalide"].push([v["delegate"], v["operations"][i]["errors"][0]["id"]])
                                                            }
                                                        }

                                                    }
                                                }
                                                else {
                                                    //console.log

                                                    if (("reception_time" in v["operations"][i])) {
                                                        if (v["operations"][i]["reception_time"] != null) {
                                                            //ajouter à t_op_erreur[round_cib][t_preendo]
                                                            if (round_cib in t_baker) {
                                                                t_op_erreur[round_cib]["t_pre_approbations"].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                                //ano_desc[round_cib]["pre_approbations"]["invalide"].push([v["delegate"], v["operations"][i]["errors"][0]["id"]])
                                                            }
                                                        }


                                                    }

                                                }


                                            }
                                            else {//endo
                                                if (round_cib in t_baker) {
                                                    if (round_bloc == round_cib) {

                                                        if (("reception_time" in v["operations"][i])) {
                                                            if (v["operations"][i]["reception_time"] != null) {


                                                                if (("included_in_blocks" in v["operations"][i])) {
                                                                    //t_op_error[retard][t_endo]
                                                                    t_op_erreur["retard"]["t_approbations"].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                                    //ano_desc[round_cib]["approbations"]["invalide"].push([v["delegate"], v["operations"][i]["errors"][0]["id"]])


                                                                }



                                                            }

                                                        }

                                                    }
                                                    else {

                                                        if (("reception_time" in v["operations"][i])) {
                                                            if (v["operations"][i]["reception_time"] != null) {
                                                                //ajouter à t_op_erreur[round_cib][t_endo]
                                                                t_op_erreur[round_cib]["t_approbations"].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                                //ano_desc[round_cib]["approbations"]["invalide"].push([v["delegate"], v["operations"][i]["errors"][0]["id"]]);


                                                            }


                                                        }
                                                    }

                                                }
                                            }









                                        }

                                    }

                                }
                                else { //L'OP est valide ?
                                    if (round_cib in t_baker) {
                                        if (("kind" in v["operations"][i])) { // preendo  if (round_cib != round_bloc) { <= aller chercher round cib
                                            if (round_bloc == round_cib) {

                                                if (("reception_time" in v["operations"][i])) {
                                                    //console.log(v["operations"][i]["reception_time"])
                                                    if (v["operations"][i]["reception_time"] != null) {
                                                        //ajouter à t_op_valide[round_bloc][t_preendo]
                                                        //console.log(new Date(v["operations"][i]["reception_time"]));
                                                        //console.log(t_baker);
                                                        t_op_pre_valide_i[round_cib].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                        //ano_desc[round_cib]["pre_approbations"]["valide"].push(v["delegate"]);
                                                        //console.log("PRE APPRO VALIDE");
                                                        //console.log(v["operations"][i]);

                                                    }
                                                    else {
                                                        //console.log("date de récep pas dispo");
                                                        //console.log(v["operations"][i]);
                                                        //ano_desc[round_cib]["pre_approbations"]["inconnu"].push([v["delegate"], "pas d'erreur + date de recep null"]);
                                                        //ano_desc[round_cib]["pre_approbations"]["valide"].push(v["delegate"]);


                                                        //date de récep pas dispo
                                                    }

                                                } else {
                                                    // jamais reçu => Manquées
                                                    //console.log("jamais reçu => Manquées");
                                                    //console.log(v["operations"][i]);
                                                    //ano_desc[round_cib]["pre_approbations"]["sequestre"].push(v["delegate"]);

                                                }

                                            }
                                            else {

                                                if (("reception_time" in v["operations"][i])) {
                                                    //console.log(v["operations"][i]["reception_time"])
                                                    if (v["operations"][i]["reception_time"] != null) {
                                                        //ajouter à t_op_valide[round_cib][t_preendo]
                                                        t_op_pre_valide_i[round_cib].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                        //ano_desc[round_cib]["pre_approbations"]["valide"].push(v["delegate"]);
                                                    }
                                                    else {
                                                        //date de récep pas dispo et valide
                                                        //ano_desc[round_cib]["pre_approbations"]["inconnu"].push([v["delegate"], "pas d'erreur + date de recep null"]);
                                                        //ano_desc[round_cib]["pre_approbations"]["valide"].push(v["delegate"]);

                                                    }

                                                } else {
                                                    // jamais reçu => Manquées également 
                                                    //ano_desc[round_cib]["pre_approbations"]["sequestre"].push(v["delegate"]);
                                                }

                                            }


                                        }
                                        else {//endo
                                            //console.log(v["operations"][i])

                                            if (round_bloc == round_cib) {

                                                if (("reception_time" in v["operations"][i])) {
                                                    //console.log(v["operations"][i]["reception_time"])
                                                    if (v["operations"][i]["reception_time"] != null) {


                                                        if (("included_in_blocks" in v["operations"][i])) {
                                                            //t_op_valide[round_bloc][t_endo]
                                                            t_op_valide_i[round_cib].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                            //ano_desc[round_cib]["approbations"]["valide"].push(v["delegate"]);


                                                        }
                                                        else {
                                                            //console.log("Pas d'inclusion au bloc => Approbation oubliée");
                                                            //ano_desc[round_cib]["approbations"]["oublie"].push(v["delegate"]);

                                                            //console.log(v["operations"]);
                                                        }


                                                    }
                                                    else {
                                                        //date de récep pas dispo
                                                        //ano_desc[round_cib]["approbations"]["inconnu"].push([v["delegate"], "pas d'erreur + date de recep null"]);
                                                        //ano_desc[round_cib]["approbations"]["valide"].push(v["delegate"]);
                                                    }
                                                }

                                                else {
                                                    // jamais reçu => Manquées
                                                    //ano_desc[round_cib]["approbations"]["sequestre"].push(v["delegate"]);
                                                }

                                            }
                                            else {

                                                if (("reception_time" in v["operations"][i])) {
                                                    //console.log(v["operations"][i]["reception_time"])
                                                    if (v["operations"][i]["reception_time"] != null) {
                                                        //ajouter à t_op_valide[round_cib][t_endo]
                                                        t_op_pre_valide_i[round_cib].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                        //ano_desc[round_cib]["approbations"]["valide"].push(v["delegate"]);

                                                    }
                                                    else {
                                                        //date de récep pas dispo
                                                        //ano_desc[round_cib]["approbations"]["inconnu"].push([v["delegate"], "pas d'erreur + date de recep null"]);
                                                        //ano_desc[round_cib]["approbations"]["valide"].push(v["delegate"]);

                                                    }

                                                } else {
                                                    console.log("jamais reçu => Manquées également");
                                                    //ano_desc[round_cib]["approbations"]["sequestre"].push(v["delegate"]);

                                                }

                                            }


                                        }
                                    }
                                }
                            }


                        } catch (error) {
                            //ano_desc["0"]["approbations"]["manque"].push(v["delegate"]);
                            //console.log("ce sont des manqués");
                            //console.log(k);
                            //console.log(v);

                        }

                    });

                    Object.entries(directories).forEach(([k, v]) => {

                        if ((+va_1) <= v[1] && (+va_1) >= v[0]) {
                            //console.log("The key: ", k);
                            //console.log("min: ", v[0]);
                            //console.log("max: ", v[1]);
                            $.getJSON(server_adress + "/" + k + "/" + va_1 + ".json", null, function (json_data) { //traitement du reste
                                var item_i = [];
                                dict_data[va_1] = json_data
                                //console.log(t_baker);
                                try { // traitement de l'info du fichier correspondant au bloc
                                    //Info relatives aux (pre)approbations valides du bloc va
                                    Object.entries(dict_data[va_1]["endorsements"]).forEach(([k, v]) => {
                                        try {
                                            if ("operations" in v) {
                                                for (let i = 0; i < (v["operations"]).length; i++) {//
                                                    if ((("errors" in v["operations"][i]))) { //dès lors qu'on trouve une erreur, on vérifier qu'il s'agit d'une erreur concernant le block ciblé(va) et son round.
                                                        if (v["operations"][i]["errors"][0]["kind"] == "temporary") {
                                                            console.log(v["operations"][i]["errors"][0]["expected"], typeof (v["operations"][i]["errors"][0]["expected"]));

                                                            var block_cib = v["operations"][i]["errors"][0]["expected"] + "";
                                                            var round_cib = v["operations"][i]["round"];
                                                            if (round_cib in t_baker) {
                                                                if (block_cib == va) {
                                                                    if ("kind" in v["operations"][i]) { // c'est un preendo
                                                                        //console.log(t_baker[round_cib]);
                                                                        //console.log(v["operations"][i]["reception_time"]);
                                                                        t_op_pre_retard_i[round_cib].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                                    }
                                                                    else {
                                                                        t_op_retard_i[round_cib].push(new Date(new Date(v["operations"][i]["reception_time"]) - t_baker[round_cib]).getSeconds());
                                                                    }
                                                                }
                                                            }

                                                        }
                                                    }

                                                }
                                            }
                                        }
                                        catch (e) {
                                            console.log(e);
                                        }



                                    });

                                }
                                catch (error) {
                                    console.log(error);
                                }




                            }


                            );
                        }
                    });


                    t_op_pre_retard[va] = t_op_pre_retard_i;
                    t_op_pre_valide[va] = t_op_pre_valide_i;
                    t_op_retard[va] = t_op_retard_i;
                    t_op_valide[va] = t_op_valide_i;



                }














                // t_op_erreur[k]= t_op_erreur_i
                //// t_op_valide[k]= t_op_valide_i
            });


            let t_cible = threshold;
            var pI_level = {};
            var d3_pI_level = [];
            new Promise((resolve, reject) => { //Qd besoin de sync : https://www.freecodecamp.org/news/synchronous-vs-asynchronous-in-javascript/
                Object.entries(t_op_pre_valide).forEach(([bloc, v_bloc]) => {
                    pI_level[bloc] = {};
                    Object.entries(v_bloc).forEach(([level, v_level]) => {
                        var card_valide_tcible = 0;
                        //pI_level[bloc][level]=
                        for (const element of v_level) {
                            if (element <= t_cible) {
                                card_valide_tcible += 1;
                            }
                            //pI_level[bloc][level]= (card_valide_tcible/(v_level.length + t_op_pre_retard[bloc][level].length))
                        }

                        //console.log(bloc);
                        //console.log(level);
                        //console.log(v_level);
                        //console.log(card_valide_tcible);
                        if (isNaN(card_valide_tcible / (v_level.length + t_op_pre_retard[bloc][level].length)) == false) {
                            pI_level[bloc][level] = (card_valide_tcible / (v_level.length + t_op_pre_retard[bloc][level].length))
                            d3_pI_level.push({ bloc: bloc, level: level, pI: (card_valide_tcible / (v_level.length + t_op_pre_retard[bloc][level].length)) })
                        }
                    })
                    resolve(d3_pI_level)
                });
            }).then(resolve => {
                console.log("Alpha: ", resolve);
                chart_alpha(resolve);
            })




        }

        try {
            $.get(server_adress, null, function (text) {
                //directories=$(text).find("a").text(); //fonctionne !!! 
                $(text).find("a").each(function () {
                    let s = $(this).text();
                })
                /*
                $('form').keyup(function (e) {
            
                //document.getElementById('launch').onclick = function() {

                beg_ = document.getElementById('selectedLevel_begin').value;
                end_ = document.getElementById('selectedLevel_end').value;
                threshold_ = document.getElementById('selectedThreshold').value;
                ComputeAlpha(beg_, end_, threshold_);

                document.getElementsByName("getElementBy").addEventListener("keydown", function(){
                    beg_ = document.getElementById('selectedLevel_begin').value;
                end_ = document.getElementById('selectedLevel_end').value;
                threshold_ = document.getElementById('selectedThreshold').value;
                ComputeAlpha(beg_, end_, threshold_);
                })

            //};
        });*/
        
                $('#submit_').mouseup(function (e) {
                    beg_ = document.getElementById('selectedLevel_begin').value;
                    end_ = document.getElementById('selectedLevel_end').value;
                    threshold_ = document.getElementById('selectedThreshold').value;
                    ComputeAlpha(beg_, end_, threshold_);

                });

                /*$('form').keyup(function (e) {
                    beg_ = document.getElementById('selectedLevel_begin').value;
                    end_ = document.getElementById('selectedLevel_end').value;
                    threshold_ = document.getElementById('selectedThreshold').value;
                    ComputeAlpha(beg_, end_, threshold_);
                    });*/
            })
        } catch (e) {
            console.log(e)
        }

        function chart_alpha(data) {
            var margin = ({ top: 40, right: 60, bottom: 30, left: 40 }),
                width = 560 - margin.left - margin.right;//1000, // outer width of chart, in pixels
            height = 400 - margin.top - margin.bottom;//400; // outer height of chart, in pixels 
            try {
                try {
                    while (document.getElementById("alpha").querySelector("svg")) {
                        const elements3 = document.getElementById("alpha").querySelector("svg");
                        document.getElementById("alpha").removeChild(elements3);
                    }
                } catch (e) {
                    console.log(e)
                }
                const svg = d3.select("body").select("#alpha").append("svg").attr("width", width + margin.left + margin.right)
                    .attr("height", height + margin.top + margin.bottom)
                    .append("g")
                    .attr("transform",
                        "translate(" + margin.left + "," + margin.top + ")");

                var x = d3.scaleLinear()
                    .domain(d3.extent(data, function (d) { return d.bloc; }))
                    .range([0, width]);
                svg.append("g")
                    .attr("transform", "translate(0," + (height + 5) + ")")
                    .call(d3.axisBottom(x).ticks(5).tickSizeOuter(0));


                var y = d3.scaleLinear()
                    .domain(d3.extent(data, function (d) { return 100 * d.pI; }))
                    .range([height, 5]);
                svg.append("g")
                    .attr("transform", "translate(-5,0)")
                    .call(d3.axisLeft(y).tickSizeOuter(0));

                var colors = d3.scaleLinear()
                    .domain(d3.ticks(0, 4, 6))
                    .range(["#5E4FA2", "#3288BD", "#66C2A5", "#ABDDA4", "#E6F598",
                        "#FFFFBF", "#FEE08B", "#FDAE61", "#F46D43", "#D53E4F", "#9E0142"]);

                var legend = d3.legendColor().scale(colors);

                svg.append("g").attr("transform", "translate(487,10)").call(legend);

                // Add the line
                svg.selectAll("myCircles")
                    .data(data)
                    .enter()
                    .append("circle")
                    .attr("fill", d => colors(d.level))
                    .attr("stroke", "none")
                    .attr("cx", function (d) { return x(d.bloc) })
                    .attr("cy", function (d) { return y(100 * d.pI) })
                    .attr("r", 2);

                svg.append("text")
                    .attr("x", -margin.left + 40)
                    .attr("y", 0)
                    .attr("fill", "currentColor")
                    .attr("text-anchor", "start")
                    .text("↑ % Preendorsements received before threshold time");

                svg.append("text")
                    .attr("x", width + margin.right)
                    .attr("y", height)
                    .attr("fill", "currentColor")
                    .attr("text-anchor", "end")
                    .text(" # bloc →");

                svg.append("text")
                    .attr("x", width + margin.right)
                    .attr("y", 0)
                    .attr("fill", "currentColor")
                    .attr("text-anchor", "end")
                    .text("Level:");



            } catch (e) { console.log(e) }

        }
    </script>
    <div id="alpha"></div>
</body>